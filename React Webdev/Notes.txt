***** Notes On React *****

Home Page for React: https://react.dev/

** React Basic **
-- Its a front-end library. [very very popular] --based on JS [Manadatory]
-- It helps build user-interfaces from components. [Components are basically Reusable JS functions]
-- A large chuck of UI can be broken down into smaller components and then can be reassemble agian. [This is what basically Reacts Do]
-- components:
   - Its a bubble that holds html, css and some JS functionality.
   - This bubble or Function can be reused whereever required in the project.
   - Most Important Thing: Reuseability

Notes:
  -- Componets are bunch of functions that knows how to render themselves.

** How to code in React **
Run React on a Server: 
-- Tool: codesandbox [Powerful tool then code-pen for building large applications]
-- To Run React: It needs some important dependencies like: react, react-dom, react-scripts.

** How we can return HTML Looking script in JS ?
  -- Its not HTML, its JSX.
  -- One of the dependency called react-script, includes one subdendency called babel/core.
  -- Babel:
    - A very important dependency that takes the JSX returned by components and Convert them to JS.
    - This After conversion into JS, it can render in browser.

** What is JSX or how React Code works ? **
-- JSX -> Javascript syntax extension.[Looks like HTML tags but not real HTML]
-- Component functions basically returns JSX. which can be rendered by browser after babel converts it to JS.

** React File Structure
-- Basically 3 files are involved when working with React
   1) index.html -> This is place where we have a default root div elements that will hold all components of the APP.
   2) index.JS -> This will use the components defined in app.js and render the root div in index.html 
   3) app.js -> Most important part of the Project. Here we define all our components functions and nest them.
NOTEs:
  -- In app.js, we always have a default component called APP. All other custom component will be child to this component.
  -- Index.html and index.js  mostly handles the rendering of the components from app.js

** How to make a Component ?
-- Give the component name as the function name[First letter should be uppercase], 
-- return JSX i.e basically return the HTML like template.
-- In order to Render the function, Inside App Function, add <funName />
NOTE:
  -- Multiline JSX returned from a compoenent must be enclosed inside div. [VImp]

** How to split the components into seperate Files ? [Normally 1 file should contain only one component]
-- ES6 moduler syntax allows import or Export functionality between the files.
-- export syntax: 
  export default functionName() { return (...JSX....)}
  OR 
  function fun() {..JSX..};  export default fun; 
-- import syntax: 
  import funName from './fileLocation'; [This will import the functionality that is exported]

NOTE: Named Exports ? [VIMP]
-- If we are trying to export multiple functions, then export/Import syntax we need to update as:
export: 
  Fun1() {...}; Fun2() {...}; export {Fun1, Fun2};
import:
  import {Fun1, Fun2} from './Filelocation';

** JSX Rules For Components
1) while rendering self closing elements like br or imag or input, we need to specifically close them as <br/> or <img />. [babbel will always looks for the closing tag!]
  eg: <input type='text' />
2) A component can only return a single element. [That's why we put all our multiLined JSX inside a div and then return that div]

NOTE:
 -- Just to wrap multi-line JSX in div can clutter the UI with a lot of div's.
 -- To avoid this, we use 
    <> .. JSX lines .... </>  [This is called fragments]
 -- Comments in JSX:
    {/* ..... */}

** How to Populate dynamic content inside JSX...
-- To escape the JSX, we define the content within {...}, The content inside will be consided as pure Javascript.

** Component Decomposition: 
  -- Big and complicated components can be broken down into smaller components. This makes it more modular in design.
  -- Smaller components then can be combined together.
  -- This creates a hirarchy of the components used to build a particular UI.

** styles in React
  -- Style elements can be written in its own css file, [mostly file name we will try to match with component Name]
  -- Then to Link the style file to our component file, we need to import the style file.

NOTE: [VIMP]
  -- INside JSX, we cannot use the keyword 'class' for adding class to JSX tags [class is a reserved word for JS]
     Instead we use className as an alterantive to include class attribute to our JSX.
  -- You can assign class attribute to the top level tag of the JSX.

** What is web-packs ?
  -- web-pack is the the one that bundles all our code Files together. It handles all the imports/exports in our project.

Links to codesandbox Project:
Basic React App: https://codesandbox.io/s/first-react-project-h39r7g
Random Pokemon Generator: https://codesandbox.io/s/random-pokemon-project-tn9t5c

** Setting up React Env locally
-- Tool we are going to use : Vite [It helps setup all the files and folder structure and dependencies required for the project]
   -- It can be used to setup project for React, Typescript very fast.
   -- It gives us the Folder and file structure and also provides us with a live dev server.
Steps:
  -- npm create vite, then press Y 
  -- select the type of project you want to build. [select React for our case]
  -- then run: npm i  [This install all the needed dependencies]   And Done. [react local setup Done]

-- To Run the Project: npm run dev [its a live server that is deployed at the given url]

** codesandbox Vs Vite:
-- codesandbox uses webpack inorder to manage the files and hold everything together.
-- Vite handles the files structure and manage if we run React locally.

NOTE: Alternative tool for setup React -> create-react-app [slightly older and slower]
-- Do the same work as Vite
-- npm command: npm create-react-app my-app

** App-walk-through:
-- All components should go under src
-- default extension for component files will be jsx [js also okay, but jsx makes it look nice and shows react icon]
-- So we have
    index.html -> main skeleton of the webpage thats includes a root div.
    main.jsx -> This takes the App.jsx and renders it to the root div.
    App.jsx -> Our master Component that contains the whole design of the page.

** Props
-- we write props that makes Component configurable. eg: <Greeting name="Hello" />
-- basically, name will be passed as key to the param Object to the Greeter function. eg: param.name will be Hello, where pram is passed as parameter to Greeter.
NOTE:
  -- Common practise while using props, we will destructure it at the component level.
-- For passing props like Numbers, Arrays or objects, We need to pass it inside { ... }; [This will escape the JSX and treat the content as pure JS]

** handling Conditions in React [2 ways]
-- If based on condition we have 2 scenarios, use tirnary Operator inside JSX within {....}.
-- If just we check Condiiton, use this, { condition && validScenario } [If condition satisfy, valid scenario will be rendered, If not -> It wont be render atall]
NOTE:
  -- Inside the {...} if we put html tags, it will render. [In tirnary Operator, we are putting html tags to render success and failure msg insied {...}]

** How to debug react tools
-- Install Chrome extension : React Dev tools.
-- It can detect websites using React and have specific Inspect methods to view all the components used.

** Ways to implement styles in Components [2 ways]

Static way [use className attribute]
  -- use className attribute to add the class you want to add to the parent div element.
  -- commonly used to apply skins from a standalone css file, for the entire component.

Dynamic way [use the inline style attribute]
  -- use the inline style attribute to style the tags. [can be defined based on some condition also]
  -- This style attribute takes all the css property [cameled case, without hypen] as key-value pair inside of a JS object
eg: <h1 style={{color: "red", fontWeight: 500}}></h1> [here, first {...} tell JSX that content is JS and second JS is actually out css properties object]

Note:
  -- While working with props of Array type. To render each element we mostly use Array's map Function.

Why Key Prop needed ?  
  -- When we work with Arrays or iterative elements, we also need to Add a unique identifier to each items we are rendering.
Solution:
  -- Add a key attribute[like how we add a prop] and assign it an unique id. [Needed because React tracks each elements with this id]

EsLint ?
-- Helps to write better code, it highlights error based on the rules configured in eslintrc.cjs file.
-- In the config files, you can config what warnings you would like to get while writing code based on the Rules.

NOTE: OPtional Concept of PropTypes [Mostly not used in Projects, Previously was in Use]
-- PopType is a package that we need to import or it comes automatically by vite.
-- It basically defines the dataType of the Prop we are passing to a component.
eg: ComponentName.propType = {
  prop1: PropTypes.String,
  prop2: PropTypes.number
}
-- If the prop dataType doesnot match then it will throw error in console.
-- The use of propType is not used much often.

[VIMP]
** React Events and Events Handler 
-- In Vanilla JS, we use DOM queryselector and eventListner to handle Events.
NOTE: 
-- All Event Names are Cameled Cased here.[Same Name as MDN docs but in React it is Cameled Case]
-- OnClick Event:
  In React, we define OnClick prop inline in the JSX and pass a function Reference name. [NOte: we pass fun[It's referes to the function] not fun()[This execute the function]]
-- Few of the Events Handler works with evt obj. [eg: OnSubmit of form, we get that evt obj default coming to the function that conatins all info regrding the event]
-- The Above works same in React. All functions that handle events have access to evt obj that contains all info about event.
NOTE:
  -- If your event expects some params other than evt object, 2 ways to handle it.
  1. Use arrow function directly at the event prop place.[Mostly preffered]
  2. Define a function that in inside the component and handle it. [It will have access to the props passed to the component]

Important Concepts in React so far:
1) Components: Building block of the UI, includes Functions, Logic and return JSX.
2) Props: Attributes passed to the components. [Cannot be updated, Component should not change prop values]
3) State: Related to Componenet Re-render/Update based on data inside the component. [It can be updated !]  eg: A couter functionality.

[VImp]
** State in React 
-- React needs to re-render Components in order to show updates. States Helps React to identify when its need to Update or re-render the Component again.

Why we need State ?
1) Used when we fetch data from APIs 
2) Handle Form Information 
3) variable that decide show or hide something.
NOTE: Basically, If anything Inside the Component has a possiblity that it can update or change or we need to re-render, we use State.

** How to Use state in React ? [This uses React Hooks: useState]
-- What are React Hooks ?
   -- This are the functions given by React to us, that we can use in our logic. eg: useState, useEffect etc..
   -- All Starts with `use..`, check the docs for more refrence.

[Imp]
* useState: [Ref: https://react.dev/reference/react/useState]
  -- It is a react hook that allows us to Use state fecture of React in Our Component.
  -- takes a Parameter that defines the starting state.
  -- It returns 2 Array elements:
     1) The state variable: The variable that is getting updated.
     2) A function: That handles the update of the variable.

NOTE: 
  -- InOrder to useState, we need to import this specifically from React.
  -- WE should always destructure the useState returned array. It always contains 2 things. stateName and StateFunction.
  -- Its Okay if we define nested function, State variable and props are not avaiable out the component scope,
     So helper functions and methods [Arrow Functions preffered] can be defined inside the component functions.
  -- Inside {...}, It itentify the content as JS, now if you want to include any HTML content, you can use tags or just <>...</>, It will be treated as HTML.
  -- Multiple useState can be used inside the same component. [NO Limit]

** Component Rendering and Life-cycle of a Component
  -- So bascially, what ever param we give to useState, It will be the default value of the state only for 1st Render.
  -- AS soon as we call the state Function,
     -- The component will re-render it selef, with the updated Value of the state.
     -- The Component will re-render with update Value, after the current Rendering is Done [VIMP]
     that is, after state-function, state variable wont update immediatly, Rather it will update on the next Render of the component.

[Imp]
* What is the right way to update State when the update the existing state variable ? [This is only when state update depends upon the prev state value]
  Problem: If we directly pass the updated state value in the state function ? eg: setCount(count + 1);
     -- For the new Count to reflect, the useState has to run again.
     -- For this, The component function needs to run again, then only the updated value will refelect.
     -- IF we call the same state function multiple times, It will fail.
  Solution:
     -- Mostly preffered while writing state function in React, when existing state value we are updating...
     -- In the state function, we pass a upadate function. [Normally, it is an arrow function]
     eg: setCount((count)=>count+1);
     -- Here, React, sends the current state and get the updated state Value for the next component Reload.
NOTE:
  -- This will still not update the count immediatly, It will get update only when the component will re-render with the latest count val.
  -- bascially, After we call the state function, React will not update the state value immediatly, It will only after it re-runs the component function again !

* Setting up Initial UseState
  -- Ideally, useState will take the param as the Initial state value and then on subsiquent Render, it will ignore it.
  -- Situation: 
     Whatif we have heavy function, that we need to pass as Initial State Value. eg: useState(runFun());
     -- Here, Not just on Initialise but Everytime the component Refreshes, the runFun will be executed and the return value will be ignored. [But the function executes that takes time]
  Solution:
    -- Instead of calling the function, we can pass it by reference. eg: useState(runFun)
    -- On Initialise, useState will execute the function and work with the return Value.
    -- On State Change refresh, useState going to ignore this fun and wont run it also. [Saves Time, Problem Solved :)]
NOTE: If the initializer function takes param, pass it like an arrow function. eg: useState(()=>runFun(param1)); [Here, Everytime, it will not execute the function when component re-render]

* When React Renders ? [How it identify state has changed or not ?]
    -- React can identify and compare the prev and the current state value to see if there is a change.
    -- If change is there, It will re-render, else it will ignore.
    -- Calling state fucntion multiple times will also not re-render multiple times, It will patch all the state functions together and re-render once.

[VIMP]
* Working with useState with mutable Objects like Arrays or Objects [We have to make Copy before we call state Function]
  -- AS such no difference, Everything is same as we do in case of number and strings.
  -- We need to take care when we update the state value.
  problem: If you update the keys of the existing Object and send it in state function. It won't work.
    -- React will compare the identity/memory Refernece of the current state value and updated state Value, Since the Obj is same and just the content is updated. [It wont Render atall]
  solution:
    -- we use the spread Operator eg: {... obj} to spread the content of the obj in a new completely new Obj, update our key and then send it to state function.
    -- Now since current state and update state are 2 different Obj, React will Render the page.
NOTE:
  -- In case of Array, Make a copy of the array into a new varaible and pass that to state Function, use [... arr] to create a newCopy of the existing arr.
  -- If we are updating a array type state value, use filter or map [REason: they return a new Array after processing]
  -- The state function, it accepts a param that represents the current state val [useful when defining update function]
  -- In case when you handle Loop over tags and needed keyProp, You can use the uuid npm library to generate uuids for keys.

* Importance of Passing key Prop while Rending loops:
  -- We need to have a unique identifier to keep track of the elements.
  -- useful for delete or update of a specific element from the List.

* Handling Common Array Type State Val:
  eg: const arr = [{key: 1, text: "a"}, {key: 2, text: "b"}, {key: 3, text: "c"}]
  
  1) To Add new Element [use the Spread Operator]
      [...arr, {key:4, text:"e}]
  
  2) To delete an Element [use Filter]
      arr.filter(e=>(e.key != 3))  -> Delete the element with key 3
  
  3) To update an Element [use Map]
      arr.map(e => {
        return (e.key === 2) ? {
          ...e, text: "kiio"
        }:e;
      })


NOTE: Play_Dice [This Component we will break down into samller componenets]

LuckyN GameRules: 
  -- You have N pair of Dice. 
  -- You Roll Them, If the sum of the Dice meets Target, [You Win]

** Why Breaking Down a Big project into Small component is Required ?
Advantages:
  -- It increases the modularity of the whole Application.
  -- Code Reuseability and easy maintainance.
  -- Multiple Resources can Work on the feature simultaneously without blocking each other.

Common Rules in React: [Important]
-- Place the State Variable as high as possible while building a Componenet.
  why ?
  -- In React we cannot send the state from a child componenet back to the parent Component.
  -- The Flow of data is downwards.
-- States From parent Component can be passed down to Child.
-- While Decoupling a component, we make 2 types of component:
   1) Presentational Component:
      -- This are just component that renders the UI based on props. [No Logic Included]
   2) Logical Component: 
      -- This components basically handles all the math and states variables.

** Destructuring the LuckyN Dice Game Structure: [Ref: LuckN.jsx component] 
  App -> LuckyN -> ShowDice -> Dice.

1) Dice Component: A simple Component, That take dice Number as prop and just display in a box.
2) ShowDice: It accepts a array prop with all the Dice Values and then Render dice component for each one of them.
3) LuckyN: This is a Logical Component. It Handles the states Values and Logic of the Game.
4) App: The parent that bundles all the above Components and render on the Screen.

** While building a component, These properties we should take care:
  1) Props: What props we need in our Component !
  2) State: What are the values that need a state and can update !
  3) Events: What are the events we are supporting ? When this event happens what Action we are going to take ?

** Handling Functions as Props [Important] [Ref: LuckyN.jsx Component][feature: Check How are handling the gameWin Logic for different Dice Game]
 -- In JS, Functions are treated as first-class i.e They can be passes as params to Other Functions.
 -- We can pass functions references as props to Component, Component then can execute that Prop to trigger the Function.
USE ?
 -- If we define a state in Parent Component, and we want Child Component to update that State ? [Very Important] [feature: Check how we are handling the Refresh Button Click Event]
 -- We can define a function that calls state update function, Then pass this function reference as Prop to the child Component.
 -- When ever child component will trigger the function, The state of Parent Component will change, which will refresh the Component.

** Why Lifting the useState to parent Component ? When we should not do it ? [feature: Check how on Click of each box, the Value updates]
  -- If the State is limited to just the child Component, then we can use the useSate just within the Child component.
  -- If the requirement is we need to Handle the state of multiple Child component, Better to Lift the state to parent component.
     then use, prop functions to send update State function reference down to the Child Components.
     This way, All The child Component can share a common Sate Variable among them.

*** React and Form Handling ***

* What is controlled componenet ? [React Controlled Component using State] [Ref: FirstFrom.jsx]
  -- It is way in which React keeps a state check on what is happening in the Component. [React state here is "single source of truth" ]
  -- React controls what the component will show and what happens when user provide input to the component.
eg: For an input in Form, We dont extract the value from the input tag like how we use in Vanialla JS using eventListners.
  Rather in React, we use a state to keep Track of the change [onChange Event] in the text value and update it in the form. [React controlling the Component] 
i.e In react, State Variable will be always in sync with what the form holds at any point of time.

* How to Link Labels with input tag in JSX ? 
  -- Normally, in JS, we use 'for' attribut in label that takes id of the input.
  -- In React, 'for' is reserved so we use 'htmlFor' instead.

* handle Multiple form inputs and Submission. [Imp][Ref: LoginFrmDemo]
  Appraoch 1: For each Input, add a useSate Variable and a updater Function. [Not Recommended, As FormSize increase, It will look awful]
  Appraoch 2: [prefered]
  -- Have a Single useState as Object that contains all the input field 'name' as keys to this Object.
  -- We have a single OnChange EventHandler.
  -- Each input field will have its name.
  -- Fetch the name of the field that updates from evt.target.name and its value as evt.target.value.  

NOTE: [VImp]
  -- In React Form, Basically all the input should have mandatory a part of form state variable.
  -- All the input tags must have value and onChange attribute to Handle Form interaction. 

* What is computed Object ? [Just a clearer way of updating Object in StateUpdate Functions]
  -- If you have varaible like first = 'test', and obj = {a:4, b: 6};
  -- Now, if we say, obj[first] = 8, it means within the bracket, first is computed that is test, so obj: {a:4, b:6, test: 8};
  -- Another way of doing the above, 
     let newObj = {...obj, [first]: 8}, Here, its gonna add test: 8 to the newObj along with the keys from obj
eg: 
    setFrmData(frmData => {
            return {
                ...frmData,
                [evt.target.name]: evt.target.value
            }
        })
Here, Taking the existing frmData, retruning a new Object, and we are computed the key name based on target.name and the value based on target.value.

** Shopping List App ** [For Implementation of Fun as Prop and Form implementation and Form Validations]
App Structure: 
1) App.jsx [Manages all Components]
2) ShoppingList [Manages all Shopping items]
3) AddShoppingItem [Handles addition of new Items][Implements Form Logic]

** Validation with Forms **
1) Do Validation Manually using custom Defined validation Handler functions [Ref: Shopping List we validated Manually]
  -- Define Validation checker functions, Either in onChange Event Handler or onSubmitEvent Handler function.
  Drawback:
    -- If we have lot of inputs, Validating them makes code more complex and too long.
  NOTE: [IMP]
  -- For Valiation, Dont use state variables, they dont update immediately, they update in the next render.
  -- Rather, use event object from event Handler functions to perform all validations.

2) Use React tool [React Hook Form] [https://www.react-hook-form.com/][Refer: FrmValiationsTool.jsx ]
  -- npm i react-hook-form
  -- Easy and faster to Handle all things regarding form.
  -- It expose a hook, useForm() that handles the input tracking, submit Event, validations before submit and error messages.

NOTEs: Important Steps while using React-hook-form [Imp]
1) Using the hook [useForm]
   -- use the hook, useForm(), [takes a param: mode -> bydefault its onSubmit, Decide when to check for valiadtions]
   -- 3 things you must destructor from the hook: register, handleSubmit and formState : { errors }
2) Validation logic for the inputs
   -- here we defined the validation logic for each of the field we have in our input. [Its a JSON Object]
   -- Most common validations: required, minLength, maxLength, min or max. 
   -- NOTE: required takes just the error message, others we need to define value and message.
   -- Check Documentation for how to write different validations.
3) Handle Form Submission:
   -- Normal the function should be defined, it receives one param bydefault which contains the formData Obj.
   -- For the formEvent onSubmit, we should pass our submit Handler function within handleSubmit.
   -- handleSubmit will apply validation and check and then pass it only if all validations are met.
4) register the inputs fields
   -- For each input, we should have name attribute and need to pass {...register('fieldName', validationObj)}
   -- the fieldName will keep track of the input Fields of the form.
5) Handle Form Errors.
   -- we will use 'errors' [the one that we destructure form useForm()] to handle errors. [By default it will be empty]
   -- Whenever some valiadtion fails, errors will have corresponding fieldName and it will contain the respective error message
   NOTE: before display error message always take care to check if the errors obj contains that field name or not ? [use errors?.password, it checks if errors have a key called password or not] 

** Using React Effects Hook ** [Refer: React_Effect App]

* What are effects means ? 
  -- Doing anything after a component re-render is called effect.
  -- Effects are mostly used for side-effects [Things that are not related to render]

NOTE: 
  -- useState is what triggers the re-render of the component.
  -- useEffect take care of things which are not related to re-render.

* Why we need Effect ? [useCase for using useEffect hook ]
  1) Handling DOM that React don't cover.
  2) Async Operations, Making a service Call using any API [When component is mounted or Rendered for the first time]
  3) Doing things when component is about to be un-Mounted.

** useEffect Hook ** [VIMP]
  -- it's basically takes a function in its param.
  -- It executes everytime the component re-render it self due to any state changes. [This is the default behavior of useEffect]
  -- There is a optional 2nd Argument [State dependencies]: Takes State variable in form of Array
     -- This makes the useEffect Run the callback fun only when the given state changes.
  NOTE: if we pass [], then the effect callback Function will run just once when the component load for first time.

NOTE: [Very Important] 
  -- In development mode, Intially when the component loads, useEffect callback fn might run 2 times.[Ignore it]
  -- In Production env, It will run just once.
REason: 
  Ref: https://react.dev/reference/react/useEffect#my-effect-runs-twice-when-the-component-mounts
  -- Well as per docs, In dev mode when strict mode is enabled, Reacts Runs a setup function before cleanup to check if everything is Okay with the code or not.
  -- This is like a stress-test that React do before actually mounting the component.
  -- Basically in prod -> setup [only one time its called]
  -- In dev -> setup -> cleanup -> setup sequence. [If cleanup is not implemented then setup runs twice, we see 2 times].
  -- cleanUp functions, we have to basically write functions that handles when the component unmount. [Ref: https://hackernoon.com/cleanup-functions-in-reacts-useeffect-hook-explained#h-what-is-the-use-effect-cleanup-function]

[Imp] [Ref: ShowDadJokes(simple component using useEffect with API Request)]
** One Big Limitation of useState initializer function.
  -- So we are allowed to pass function Reference to UseState that executes only the first time when useState runs.
  -- BUT, we cannot pass a async function [Function involves promises/ API data fetch] as initialiser function.
  -- It simply wont wait till the API returns Response, The state will store a promise Object by default in this case.

Solution:
  -- Use useEffect hook, and calls the async Function in the callback.
  Problem: Here also you cannot pass a async function directly, It won't wait !
  solution: 
    -- In the callback function, Either define the async function there and then immediatly execute it.
    -- IF the async function is already defined, in the callback function, just call the async function.

NOTE: What happens  when you call multiple set useState functions in sequence ?
  -- In Case we dont have async Functions, React stich all the set useState functions in one and re-render the component with the updated state value.
  -- In case we have 1 normal set state fun and then we have async func inside where we are calling set state fun again ? [REf: In ShowDadJokes, we are doing similar onClick handle function]
     -- Here, first the normal setState triggers a compoent refresh, 
     -- Then after sometime when the async func is done and set state fun are called inside the .then chain, It will trigger another refresh.

REF: FetchGitProfile [uses 2 seperate components [one handles form, other handles data and renders the info] and useEffect and useState Hook]

-------- This Solves our Problem on how to handle API requests in React Components ---------

*** Material UI and React *** [Set of pre-built components that we can use in our project.]

  Ref: https://mui.com/material-ui/getting-started/installation/

  -- Material UI is a library of React UI components that implements Google's Material Design.
  -- Node Package needed : 
      1) Depending upon the style Engine: npm install @mui/material @emotion/react @emotion/styled [for emotion styled engine]
      2) Roboto Font: npm install @fontsource/roboto
      3) Icons: npm install @mui/icons-material
  -- Basically, For any Component References Go by the Docs and copy paste the code.
  -- Whenever you use any component, Remember to import that Component.

NOTE:
  -- for Instance, the Button tag of MUI and Button tag from html are 2 different things, One is a component and the other is a HTML Tag.
  -- Though both of them can accept the same attribute. [the MUI button is built with the html button tag only]

NOTE:
  -- Often attributes like error in TextField MUI component, diabled in button and textBox, or helperText in TextBox Component,
     we want to toggel them, So Basically, these are boolean field, Based on the state, you can set is either true or false.
  -- For attribute like helperText that takes a string, If based on condition, if the text is not given, React will ignore this attribute. [same as toggeling them].

** How can we Add Custom Style to MUI Components **
  -- Basically, we have one attribute called sx, sx takes an Object where we define our custom Style.
NOTE: 
  -- The sx Object doesnot Follow the Normal css syntax, Its a bit different. [follow the docs while defining them]
  -- here p is padding and m is margin and width and height takes just a number [we dont pass px or rem or ems]

  REF: MyTODO [App Built with Material UI and React Important Concepts of States and Effects]