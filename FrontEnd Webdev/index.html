<!DOCTYPE html>
<html>

<head>
    <title>My HTML WorkBook</title>
    <p>NOTE: only the meta-Data included in Header</p>
    <h1>WorkBook</h1>
    <nav> Table of Contents:
        <ul>
            <li>Fronted TechStack:
                <ul>
                    <li>HTML WorkBook</li>
                    <li>CSS WorkBook</li>
                    <li>JS World</li>
                </ul>
            </li>
            <li>Observation And Important Points From FrontEnd</li>
            <li>Prototype, Class and OOPs in JS</li>
            <li>BackEnd TechStack:
                <ul>
                    <li>Bash Basic, GIT and NODE JS </li>
                    <li>EXpress Package </li>
                    <li>Template Engine, EJS and partials </li>
                    <li>DataBase, Mongo </li>
                    <li>Authentication, Bcrypt </li>
                </ul>
            </li>
        </ul>
    </nav>
</head>
<br>
<br>

<body>
    <main>
        <p>The Reference for HTML Elemnts ---> <a href="https://developer.mozilla.org/en-US/docs/Web/HTML">MDN HTML </a></p>
        <p> This is where the body starts</p>
        <p>This is a first paragraph details</p>
        <div>
            <p> Sourav </p>
            <p> HI THis is Sourav </p>
        </div>

        <h2>heading Two</h2>
        <p>Lorem ipsum, dolor sit amet consectetur adipisicing elit. Esse maiores modi, ipsa aliquam placeat similique
            rerum
            recusandae possimus sit atque fuga, blanditiis in eius odio praesentium incidunt quo magni nam.</p>
        <h3>Sub-heading one</h3>
        <p>Lorem ipsum dolor sit, amet consectetur adipisicing elit. Ab voluptatibus fugit a repellat veritatis illum
            sunt. Lorem ipsum, dolor sit amet consectetur adipisicing elit. Aut nostrum eveniet perspiciatis ab
            excepturi, atque provident accusantium ex! Quibusdam impedit, fugiat ullam provident quasi porro assumenda
            dignissimos placeat libero incidunt.
        </p>
        <h4>sub-sub-heading two</h4>
        <p>Lorem ipsum dolor sit amet consectetur adipisicing elit. Consequatur veritatis temporibus ab minima! Impedit
            at
            nam porro similique sequi! Atque minima officiis nemo impedit amet, voluptatibus error quae porro? Eos.
            Dolorem, architecto harum, numquam perferendis dolores exercitationem deserunt, magnam libero praesentium
            debitis quod quaerat nemo. Voluptas, amet minus molestiae, neque quisquam quam doloribus consequatur ad
            maxime</p>

        <h2>heading Three</h2>
        <p>Lorem ipsum dolor sit amet, consectetur adipisicing elit. Voluptatibus consequuntur voluptatum veniam
            possimus</p>

        <h2>heading Four</h2>
        <p>Lorem ipsum dolor, sit amet consectetur adipisicing elit. Aperiam aliquid accusamus quaerat dicta
            necessitatibus
            id quas natus amet, mollitia maxime provident illo reprehenderit fugit earum ipsum quidem perferendis qui
            pariatur.</p>

        <h2>Lists in html</h2>
        <h3>unordered List</h3>

        <!--This is a comment for the unOrdered List-->
        <section>
            <ul>
                <li>First element
                    <ul>
                        <li>Sub-elemnt one</li>
                        <li>sub-element Two</li>
                    </ul>
                </li>
                <li>Second elemnt
                    <ol>
                        <li>sub-element one</li>
                        <li>sub-elemnt two</li>
                        <ol>
                            <li>sub-sub-element</li>
                        </ol>
                    </ol>
                </li>
                <li>Third element</li>
            </ul>
        </section>
        <h3>ordered List</h3>
        <ol>
            <li>First elemnt</li>
            <li>Second elemt</li>
        </ol>

        <!--This is an Anchor Tag example-->
        <!-- command to comment a line (Cntrl + /) -->
        <h3>Anchor Tags -- HyperLink </h3>
        <nav>
            <h4>My fav songs links :)</h4>
            <ul>
                <li><a href="https://www.youtube.com/"><img src="youTube.png" alt="Click ME"></a> for youtube </li>
                <li><a href="https://www.youtube.com/watch?v=2v0InJbwc9E">love maybe</a></li>
                <li><a href="https://www.youtube.com/watch?v=RUUI0PilSiE">My Dear love</a>
                </li>
                <li> <a href="https://www.youtube.com/watch?v=pcKR0LPwoYs">stay with me</a>
                <li><a href="https://www.youtube.com/watch?v=WpLkJD5jKrQ">Say yes - Punch</a>
                </li>
                <li><a href="https://www.youtube.com/watch?v=gFV4ZRGU_Zk">Yours - chaneyolx Raiden</a></li>
            </ul>
        </nav>
        <br>
        <h3>Image in HTML</h3>
        <p>Reference for all the icons you need. <a href="https://icons8.com/icons/set/food"> Icons Mela </a></p>
        <img src="youTube.png" alt="YouTube Image" style="width:45px; width:44px">
        <br>
        <img src="https://img.icons8.com/stickers/344/mac-os.png" alt="apple Logo" style="height: 45px; width:43px">

        <!--This is the Notes on the some of the commonly used attributes -->
        <h3> Notes on some elements that will be used Later</h3>
        <ul>
            <li>Block Elements --> take the entire block eg: p,div,h2 </li>
            <li>Inline Elements --> doesnt break the line eg: a,img,b </li>
            <li>Divs --> This will occupy the entire block.</li>
            <li>Spans --> this will be used to select and modify the inline words or content. </li>
            <li>hr --> Its a horizontal Line </li>
            <li>br --> Break the line</li>
            <li>sup --> superscript. eg: Test<sup>2</sup></li>
            <li>sub --> subscript. eg: H<sub>2</sub>O, <sup>1</sup>/<sub>2</sub> </li>
        </ul>

        <h3> HTML Entity </h3>
        <p>Refernce for all the Entities you can use: <a href="https://dev.w3.org/html5/html-author/charref"> Enities
                List
            </a></p>
        <ul>
            <li>Less than and greater than bracket: &lt; 6 &gt; 5 </li>
            <li>spaces (before sourav): My name &nbsp; Sourav &hearts; </li>
        </ul>

        <h3> Semantic Markup </h3>
        <p> Very useful for screen Reader. It helps it to understand the code by providing anchor points like the
            header, main section etc </p>
        <ul>
            <li> If you just properly name the divs like using main, article, aside, header, footer, section or nav
                thats gives meaning to the markup text.
            </li>
            <li>
                <aside>This aside element is used to seperate a specific part of the content which is just there but
                    not a part
                    of the main content OR Additional Info on the content.
                </aside>
            </li>
            <li> We have other elements that we use like figure that goes with figcaption (img with caption)</li>
            <li> time with datetime attribute to call out that the content is a date type. </li>
        </ul>

        <h3>Emmet Demo (Shortcut for Vs that works with HTML)</h3>
        Click here to Go to <a href="emmetDemo.html">Emmet Demo</a>

        <h3> HTML Tables </h3>
        Click here to Go to <a href="htmlTables.html">HTML Tables</a>

        <h3>Html forms </h3>
        Click here to go to <a href="htmlforms.html">HTML Forms</a>

        <h3 id="cssworkbench">The world of Css</h3>
        For Refernce of css visit <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Reference">MDN CSS</a>
        <p>For Css Workbook <a href="cssworkbook.html">Click here</a></p>

        <h3>The World of JavaScript</h3>
        <p>WE can practise the basic JS in inspect console.</p>
        <p>Click here to Go to Js Home and open console: <a href="javaScriptFolder/javaScriptHome.html">Click here</a>
        </p>
        NOTES: <ul>
            <li>Console follows: REPL: Read Evaluate Print Loop </li><br>
            **Basic Methods**
            <li>5 primitive dataTypes: number, String, boolean, null and undefined</li>
            <li>Order of invocation- <b>PEDMAS</b>: Parenthesis() > Exponential(**) > Divide(/) > Multi(*) > Addition(+)
                > Subtraction(-)
                (Wiser: USE *BODMAS* Always works)
            </li>
            <li>NaN is a special member of number. eg: 0/0 </li>
            <li>variable declaration: let, const(value is fixed) and var(old implementation, similar not same as let)
            </li>
            <li>In Strings: If want to put some evalution inside the string we can do that using string literals. eg:
                `Hello this is evaluation ${a + b}.`</li>
            <li>Note: here we have to take care of putting the string inside `.....`</li>
            <li>For Comparision, == Will not care about the type(it will convert both in one type and than compare) but
                === will consider type.(It will not compare covert)</li>
            <li>eg: '2' == 2 --> true (both converted to string and compared), '2' === 2 --> false. (one is int and
                other is string so it is false.)</li>
            <li>prompt can be used to accept inputs from the user in the browser.</li>
            <li>All Script links make sure you put it at the end of the body.</li>
            <li>everything in Js is truthy except these: false, 0 , "", null, undefined, NaN (this are falsy)</li>
            <li>In String, We can't modify any letter in any String.</li>
            <li>push and pop --> add and remove from the end, Shift(remove from the first) and unshift(add in the first)
                --> from the begining of the array</li>
            <li>Note: push returns post of the added ele, unshift() returns the length, pop()/shift() return the deleted
                element.</li>
            <li>Slice -> get a portion of the array(startIndex, endIndex(optional)), splice --> it replace the orignal
                array.(stratIndex,deleteCount,element1,element2,.....)</li>
            <li>Note: slice --> the last ele if not given goes till end. if given it will go till index-1. splice --> if
                deleted returns the deleted ele else if added then return empty arr.</li>
            <li>arr.includes(xyz) check if xyz present in the array or not.</li>
            <li>Warning: For JS just sort() won't work for sorting numbers. We have to write a function for numeric sort
            </li>
            NOTE:
            -- sort() works well on Strings, For Number also it converts the ele to String and then sort.
            -- sort() for numbers eg: arr.sort(function(a,b){return a-b}); Sort in ascending Order.
            <li>[] === [] is false. == or === never compares the content of the array.</li><br>
            <li>Math.random() -> generates Random Between 0 to 1 but excluding 1.</li>

            **Arrays**
            <li>In Js, Arrays is accessed using refrences. so when you say let num =[1,2,3] that means num points to
                [1,2,3] i.e store the address of it, If i say letnumCopy = num than any changes in the num or numCopy
                will modify the same array.</li>
            <li>In above senario, num === numCopy why ? Because they are pointing to the same array.</li>
            <li>In Js, Objects are the collection of properties. Properties contains key --> Value.</li>
            <li>Every key is converted into a String.</li>
            <li>To Way to access the data: use '.' operator eg: obj.keyName OR use obj["keyName"] to get the value.
                (Advantage: inside the bracket we can write any exp or variable) </li>
            <li>NOTE: To delete a key in Object we can use: delete Obj.keyName </li>
            <li>Number guessing game using js: <a href="JavaScriptFolder/numberGuessingGame.html">Click here</a> to see
            </li><br>
            ***Important**
            <li>For..Of Loop can be used to iterate in the loop.</li>
            <li>For..in Loop used to iterate over the Object. It will return the keys.</li>
            <li>Object.keys(ObjNames) --> Gives List of the keys, Objects.values(ObjName) --> Gives the List of Values,
                Object.entries(ObjName) --> Gives all the entires of that Objects in 2-D List.</li>
            ***
            <li>Check Out the Console Based ToDoLsit APP ----> <a href="JavaScriptFolder/ToDoAPP.html">Clcik here</a>
            </li><br>

            **Functions**
            <li>**Block Scoping --- > Any thing defined within {} then that variable is local within that scope.</li>
            <li>**IMPortant ---> If we use var than we can use a block variable outside the block. *** </li>
            <li>Lexical Scope --> Inner fucntion have access to parent function's variables.</li>
            <li>Fucntion Expression : eg: const add = function(var1, var2) { return var1+var2; }, calling of this
                function: add(4,5); Here the function has no name but we are storing the result in a variable. (One more
                way of declaring functions).</li>
            <li>Very Imp --> Function as parameter and function as return Type. (see the app.js)</li><br>
            ***Methods:
            <li>This are functions added inside the object and can be used using '.' operator after object name.</li>
            <li>*this* keyword is used inside of an object mostly to access its own properties.</li>
            <li>this mostly points to the object before the dot.</li>
            <li>NOTE: If this doesn't find any reference point than it points to the "window" object.(The Parent Object
                for everything like alert, prompt, functions etc.)</li><br>

            **Important Array Methods**
            <li>forEach(Not used now a days since we have for..of method) ---> it will execute a function for each
                element of the array, where it will pass the element automatically..</li>
            <li>Any parameter you give inside the callback Func in the forEach, is taken as an element of that array.
            </li>
            <li>Map --> same as forEach but the difference is it will create a new array i.e this will have a array as a
                return type for using map.</li>
            <li>ArrowFunction--> It's allows to write a function without writing the keyWord fucntion. eg: const add =
                (x,y) => {return x+y}; </li>
            <li>if you have multiple params ->const sum = (x,y,z..) => {return ...}, single -->cosnt sum = num =>
                {return ...}, No params -->const sum = () => {return ...}</li><br>

            **NOTE**
            **just a reminder (How to declare a function 3 ways)
            <li>1) use function keyword --> funciton sum(x,y) {return x+y;}; let output = sum(x,y);</li>
            <li>2) use the return type(mostly used) --> const sum = function(x,y) {return x+y;}; let output = sum(x,y);
            </li>
            <li>3) use of arrow fucntion(mostly used in callbacks) --> const sum = (x,y) =>{return x+y;}; let output =
                sum(x,y);</li>
            ********
            <li>Implicit arrow fun --> syntax: const add = (x,y) => (x+y;); //NO need to write return and use {} since
                we have only one line to return.</li><br>

            **New functions, Will use this later in Async JS.
            <li>setTimeout --> it is used to delay the execution of the function. parmas--> setTimeout(function() {},
                millisecond)
            </li>
            <li>setInterval --> same param structure as above, It will call that fucntion after every interval</li>
            <li>NOte --> to stop this, we have clearInterval(id), pass the id retrun by the setInterval function here
            </li><br>

            **Filter method in Array.
            <li>usecase --> it returns a new Array based on the condition of the callback fucntion.</li>
            <li>example --> const newArr = arr.filter(element => {retutn condition if satisfy it will be put in the new
                array.})</li>
            **NOTE**
            <li>MAP--> used to pick element from the List, FILTER --> based on a condition we will pick element from the
                List.</li><br>

            ***Bollean Array Methods --->**SOME and EVERY**
            <li>Syntax --> Arr.some(element => condition), Based on the condition this will return either true or flase.
            </li>
            <li>Every --> if all the elements satisfy the condition then it return true else false</li>
            <li>Some --> if any one of the element satisfy the condiiton then its true else false</li><br>

            **Array Method --> Reduce
            <li>syntax--> arr.reduce((accumulator, currenValue) => {return ...}, initalValueOfAccumulator(*optional*))
            </li>
            <li>accumulator --> it stores the result of the return code.</li>
            <li>currentValue --> iterate one by one on the element.</li>
            <li>example --> get the sum of all elements in the array.</li>
            <li>usecase --> find the min or max value in the array.</li>
            <li>**Reduce also allows to take the second params that specify the initial Value of accumulator.**</li><br>
            <li>Note:
                -- The accumulator starts with the first val of the arr, currentval iterates over all the element. **IMP**
            </li>

            **NOTE this keyword-- Very Important**
            <li>ideally this refers to the windows object.</li>
            <li>this by default points to the windows object</li>
            <li>but when you use a normal function then, this points to the objet which is executing that function, in
                this case nothing to do with the scope</li>
            <li>Inside an Arrow function, this refers to the same Object where the function is created.</li>
            ***IMP***
            <li>Never use arrow functions and this to define methods, by default it will point to the windows object
                instead of the current Object</li><br>
            NOTE:
            <li>See, 
                -- this keyword in Arrow function will try to find up, where is the function keyword above it.
                -- if it finds a funtion keyword it will point to that obj.
                -- this keyword in Function keyword defined, points who is executing that function. points to that obj.
            </li>

            **New Features in JS**
            <li>*default parms -> check if the param has some value if not assign it a dafult one</li>
            <li>syntax -> function rollDie(a, b = 6) {...} --> here if the b is coming it's fine else b will be 6
                default</li>
            <li>NOTE: Check for the order of the param, it matters here.</li>
            <li>*Spread --> It will spread the elements of an iterable into seperate arguments</li>
            <li>syntax --> we have an array Arr contains numbers, Math.max(...Arr), "..." this will convert the arrays
                as different arguments.</li>
            <li>usecase --> suppose we need to find the max element in the array using Math.max() method.</li>
            <li>*Spread in Objects --> we can use this to copy Object</li>
            <li>special case -> {...[2,3,4]}, here the obj will have indices as keys and element as value</li>
            <li>useCase --> to combine various objects, to copy object, to add new add elements to the existing obj</li>
            <li>*REST parameter --> it collects all the arguments you pass in the function in an array</li>
            <li>syntax --> function sum(...nums) { //code }, all the elements you pass to sum will be collected by num.
            </li>
            <li>example --> collect all the params passed, const collectAllnums = (...nums) => { console.log(nums);};
                here no matter what you put as param to sum, num will collect it in the array</li>
            <li>*Destructure Array --> copy out values from array</li>
            <li>syntax --> suppose we have arr= [1,2,3,4,5,6,7,8], const[first,second,...otherValues] = arr; then first
                will be 1, second will be 2, otherValue will contain the rest of the values </li>
            <li>*Destructure from Object --> To fetch properties in a seperate variable from the object.</li>
            <li>syntax --> lets say you have an obj const class = {name: 'Sou', number: 50 }, then const {name:
                className, number : classStrenght = 'N/A'} = class;</li>
            <li> the above will create 2 variables className and classStrength and assgin them the Value from the
                Object, If classStength not found then it will use the default value of N/A</li>
            <li>*Destructuring in the param --> Mostly used in case of an Object.</li>
            <li>syntax --> const profile = {firstName: "sou",lastName: "Mitra"}, function displayName({firstName,
                lastName}) {//code...}</li>
            <li>What happenes above is, the function is expecting an object and onEntry only we have destructure the obj
                into firstName and lastName variable to be used inside the function.</li>
        </ul>
        <br>
        <hr>
        <h3>Integrating JS with Html and Css</h3>
        <h4>The World of DOM</h4>
        <p>Playing around with DOM using JS document Objects, html and css.</p>
        Click the below to go the respective projects Folder.
        <ul>
            <li><b>Manipulating:</b> <a href="manipulating/index.html">Go here</a></li>
            <li><b>Flexbox and Responsive:</b> <a href="flex_box+responsive/index.html">Go here</a></li>
        </ul>
        </p>
        Notes:
        <ul>
            <li>DOM --> Document Object Model</li>
            <li>This provides JSobjects to link JS with various html and css elements.</li>
            <li>Document is a special OBject in JS, console.dir(document) --> this will show all the available DOM
                objects for that particualr webpage.</li>
            <li>JS will take this html and css element and it returns this Document objects for it to access.</li>
            <li>document has one object called "all" --> shows all the html collection object in the page. it returns an
                array of all the objects. </li>
            <br>

            <p>***DOM SELECTORS***</p>
            <p>**Methods used for select elements from html using DOM</p>
            <p>Ref: <b>Selecting and Manipulating:</b> <a href="selecting/index.html">Go here</a></p>
            <li>1) getElementById --> it returns the object of that particular element for that id else return null</li>
            <li>2) getElementsByTagName --> select more than one element at a time, returns all the elements with that
                tag(eg: img,div,p,b etc) in form of html collections,
                **NOTE: this collection is not an arrays but we can iterate over it, each of them are objects.</li>
            <li>3) getElementsByClassName --> fetch all the elements object with that particular class name.</li>
            **NOTE:
            If getElementsByClassName and getElementsByTagName unable to find anything it will return an empty html
            collections.
            <li>4) querySelector --> just one method to select whatever we need, But it will just return the first
                match.</li>
            <li>5) querySelectorAll --> Same but it retruns a collection.</li>

            *Properties and MEthods mostly used in DOM

            *DOM Manipulation (basic) --> can manipulate the inner elements of an DOM Object.
            <li> .innerText (fetch all the texts), .textContent (fetch every piece of content), .innerHTML (fetch the
                entire html format for that content, you can straight modify the html content using this.) </li>
            NOTE:
            If suppose a text is hidden(display: none), then innerTexr will not show it but textContent will.
            Attributes:
            <li>we can manipulate the attribute of an element. eg: document.querySelector('#banner').src = "img.jpg"
                //this will update the img with the id banner.</li>
            <li>NOTE: we have getAttribute or setAttribute that can be used. </li>
            <li> ***Imp: small diff: if you use getAttribute it will fetch from html content but if you do
                .attribute_name then it will fetch from JS Object. (most of the both will be same.)</li>
            **IMP -->
            Style Attribute manipulation: eg: document.querySelector('h1').style.border = '2px solid blue';
            <li>This style will change the stuff in the page but it is not what we have in the style sheet.</li>
            <li>This looks for the inline style attribute that we add.(Which is a bad practise.)</li>
            <li>NOTE: (**just to get we use this but cannot modify them**)
                To get proper style we can use the windows object... </li>
            eg: window.getComputedStyle(document.querySelector('h1')).fontSize;

            <li>.ClassList --> This returns the list of all the class applied to a particular object. available functs :
                .add(), .remove(), .contains(), .toggle() [this like turning this class on or off]</li>
            <li>.parentElement --> This will take you up a level from your current position in the html file. (each
                element an have only one parent)</li>
            <li>.children --> multiple children of your current place, it will return a list of all children.</li>
            <li>.nextSibling/.previousSibling --> take you the next or previous node. (IMP--> node is DOM NODE)</li>
            <li>.nextElementSibling/.previousElementSibling --> take you the next or previous element in the html.</li>
            <li>document.createElement() --> this will create a new element for you to use.</li>
            <li>.appendChild --> this will append as the last child of the given class</li>
            <li>.append/.preappend --> add some to the existing element.</li>
            <li>firstH1.insertAdjacentElement(position, element) --> at an element at a very particular position.
                (firstH1 is a DOM Object)</li>
            <li>.removeChild() and .remove() --> use to remove a child element. for .removeChild()- Go to parentElement
                and then delete it, .remove() works directly.</li>
            NOTE: removeChild --> will param as Dom Objects.
            <p>
                Small Project for displaying all Pokemon using DOM :
            <div><b>Pokemon List:</b> <a href="pokemonDemo/index.html">Go here</a></div>
            </p>


            <p>***Dom Events***</p>
            <p>Ref for Events: <a href="DomEvents/index.html">Click here</a></p>
            <li>JS Listen to every small action we do on the web page and react to it --> this called Events.</li>
            <li>Total 3 ways in which one can choose how a Js will respond to an Event.</li>
            <ol>
                <li>Add the event as inline to the attribute in html code. (*Not Recommended)</li>
                <li>use the Dom Element to bind any event. like document.queryselector().onclink = () => {...your
                    code...}</li>
                <li>using .addEventListener('click', function() {..Your Code..}) NOTE: go to mdn for the reference for
                    all the actions</li>
            </ol>
            <br>
            Note:
            <li>Advantage of addEventListener, we can add multiple functions for the same event. older ones are
                retained. Also provides additional options.</li>
            <li>In sort its more flexible and also it has removeEventListner for removing a particular event.</li>
            <li>The keyword this can be used in the callback function of the addEventListner function.</li>
            <br>
            Note: EventObject and keyboard Events.
            <li>An EventObject is bydefault passed to the callback fun of the eventListner. contains info about that
                event.</li>
            <li>Keyboard events -> keydown (When you press any key) and keyup (when you release a pressed key)</li>
            <li>the event Object here most used --> key (the key that is pressed) and code (actually location of the key
                that is pressed)</li>

            <p>**Form Events**</p>
            <li>Refer the top link for Form Event Add Note Exercise.</li>
            <li>Ideally when you submit a form the action attribute in the form will refresh the page.</li>
            <li>But we can prevent the page from loading and redirecting to a new page.</li>
            <li>Evt.preventDefault() --> Do the above work.</li>

            <p>**Other imp Events**</p>
            <li>change Event --> triggers when you type something and clicked out. basically it track if any chnage
                happened to the input.</li>
            <li>input Event --> Basically track any activity if user click on the input bar.</li>
            NOTE:
            <li>Diff between change and input --> change triggers only when blurred out of the input field, input is
                every activity on the input field.</li>
            <li>Diff between input and keyboardEvent --> keyboard event just listen to any keyboard action, input event
                listen to anything like copy, past, shift and all.</li>

            <p>***Event Bubbling***</p>
            <li>sometime when events are nestested like you have a button inside a para and both have events. then this
                is messed up, all events will be triggered if you click on the child element !!! </li>
            <li>*USE: sometime you want this feature. like if you click on the child element then parent element also
                should do something. Mostly, In general not used.</li>
            <li>EventObj.stopPropagation() --> this method on the event object restrict the click Event to only that
                particular Element. RESTRICT BUBBLING !!! </li>

            <p>***event delegation***</p>
            <li>this feature is very handy when inside a parent event you want to perform specific child action.</li>
            <li>Example--> for an action defined on an ul, you want to know the click when its a Li element
                specifically.</li>
            <li>Here we will mostly use <b>EventObject.target</b> to know which element is clicked inside the parent.
            </li>

            <p>****Small project using DomEvents****</p>
            <li>Note: We will be using a different css library called <b>Burma</b>.</li>
            <p>Click here to Go to Badminton Score Count Page: <a href="ScoreCounter/index.html">Click here</a></p>

            <li>***Note:***</li>
            <li>Never write the callback functions like a function call. It will execute the function without listening
                to the event.</li>
            <li>You either put the called function inside the callback. eg: function () {..calledFun(parm1,parm2);..}
            </li>
            <li>Or You can just pass the ref to that function, means just the function name. eg: see the example of rest
                function in the above example.</li>
            <li>fun() --> you wish to execute the fun then and there. fun --> you passing the fun as ref.</li>


            <p>***** Async JavaScript (Important)**********</p>
            <li>Note: (imp) Js practise for async: <a href="asyncJs/index.html">Click here</a></li>
            <li>Call Stack: It's a mechanism that JS uses to know here it is currently in case of multiple fucntion
                calls.</li>
            <li>Note: This is same as call stack in any other programming. It keeps track of all the function calls
                during run-time.</li>
            <li>JS single threaded: Js can run at most one line of code at a time. (But it doesnot seems that way...)
            </li>
            <li>NOte: In case of request delay or server delay, The entire page just dont hang. This kind of tasks are
                usually given to the browser(written in c++ can handle such tasks).</li>
            <li>The browser call stack can identify such WEB API Functions (special requests like setTimeout or Request
                calls) and it helps Js to manage that delayed response.</li>
            <li>The browser makes the Js to run the callback functions after the response received.</li>
            <li>callback functions: This are very useful and can be used while nesting functions. example:
                successcallback, errorcallback.</li>
            <li>callbacks mostly used in delayed code execution. and a single function can have multiple callbacks i.e
                successcallback, errorcallbacks.</li>

            <li>****Promises****</li>
            <li>Obj representation for the event of failure or success of an async operation.</li>
            <li>It is a new implementation. solves the problem of callback hell.</li>
            <li>Promise is an Object. That initially have status pending but eventually depending upon the response it
                will be either resolved(in latest version it shows fulfilled) or rejected.</li>
            <li>after getting the promise obj. we use .then(()=>{...}) for success and .catch(()=>{...}) for failure for
                the calling function.</li>
            <li>To reduce the nesting you can return inner promise calls and chain its .then() one after another, use
                single catch for catching error for all the service calls.</li>

            <li>****Async Functions****</li>
            <li>syntax "makeup" for promise i.e just make it easy to write.</li>
            <li>async and await we will be using for making promise cleaner in syntax.</li>
            <li>****async***</li>
            <li>To make a function async add async infront of the function.</li>
            <li>A Async function returns a promise object always. **IMP**</li>
            <li>If the function returns something then the promise is resolved and if it throw anything then it is
                rejected.</li>
            <li>****await***</li>
            <li>add await keyword infront of the async func call.</li>
            <li>It will basically wait for the async function to return the promise which is either resolved or
                rejected.</li>
            <li>****use of async and await***</li>
            <li>It is easy to understand and look nice instead of .then() chain for promise implementation.</li>
            <li>So you have a async fun or a fun that return promise object. Declare a new async function and use await
                before the promise func calls.</li>
            <li>if the promises are successfull store the resp in some var and use it.</li>
            <li> put all this inside a try-catch block. the catch block will catch if any req failed in the try part.
            </li>

            <p>********Ajax and APIs********</p>
            <li>AJAX -> async javascript and xml (Old implementation --> data from server used to return in formate of
                xml.)</li>
            <li>used for making/fetching/creating requests behind the scenes of a already loaded webpage.</li>
            <li>APIs -> Application programming interface. basically its the communication medium how software talks to
                one another.</li>
            <li>Web Apis --> web based apis eg: http-based web server apis.</li>
            <li>Web Apis returns data in form of JSON from the servers. That is further proccessed to put on the
                website.</li>
            <li>AJAJ --> Async javascript and json. Note: now a days all server req returns data in json format.</li>
            <li>JSON --> JavaScript object notation. It is a way of formatting data.</li>
            <li>JSON.parse(jsonResp) --> jsonResp is the string resp from the server. This function parse json data to
                javascript object</li>
            <li>JSON.stringfy(javascriptObj) --> It do the other way around. Convert JavaScript Object to valid JSON
                Format for sending them over Apis.</li>
            <li>NOTE: Basically JSON can be parsed into any Language using the inbuilt functions.</li>
            <li>HTTP Verbs --> eg: GET, POST, PUT, DELETE</li>
            <li>HTTP Status Code --> refer MDN WEbsite for general idea on differenet types of status code. Most common
                -> 200, 201, 405, 404, 504, 301</li>
            <li>http query --> the url that we hit contains the following</li>
            <li>eg: :id --> id is a variable, query --> ?sort=desc&color=red(optional if added will not affect the url
                even if its wrong. Returns only if that particular query is supported.)</li>
            <li>? --> look for that particular values. commonly used for forming redirect urls on search</li>
            <li>http Headers --> generally contains additional info on the req. ex: accept : application/json (you want
                the resp in json formate)</li>

            <p>***How to make Request from scripts ***</p>
            <li>Click here to go the page. <a href="JSRequests/index.html">Click here</a></li>
            <li>XHR --> XMLHttpRequest (old way of making a req from JS)</li>
            <li>NOte: XHR doesnot support promises and includes a lot of callbacks and Have Clunky syntax.</li>
            <li>Fetch --> Newer and better way of making request calls via JS. </li>
            <li>Note: it supports promises and its better then XMLHttpRequest.</li>
            <li>so fetch() returns a promise. it can either resolved(use .then()) or rejected.(use .catch())</li>
            <li>IMP: we wont be able to see the data. so we need to parse it by adding resp.json() which agains return a
                promise.</li>
            <li>Axios --> 3rd party lib for requests and working with them and make it simple.</li>
            <li>Note: Behind the scenes it uses fetch(). </li>
            <li>Axios returns promise. But it fetch us the data that is already parsed in JSON(very very helpful !)</li>
            <li>Click here to see the docs --> <a href="https://axios-http.com/docs/api_intro">Axios</a></li>
            <li>NOTE: for including req headers: axios('url', obj). here obj container header, it may also contains
                params</li>

            <p>Example of <b>Tv Show Search web Application</b> which uses TvMaze APIs. <a
                    href="TVShowSearchApp/index.html">Click here</a></p>

            <hr>
            <hr>

            <p>Practise Space 1: Revise all previous topics from JS: <a href="JSPractise/index.html">Click Here</a></p>

            <p>Observations and notes for revision before DOM:</p>
            <p>Observation:<br>
                1) when keys are inserted into the object they are stored in a sorted manner.
                2) when we print the object.keys() it returns in the order they are inserted.
                3) arr.includes(xyz) check if xyz present in the array or not.
                4) var doesnot follow block scoping i.e available everywhere but let obeys block scoping i.e available
                only in {}
                5) function params dont need type declaration.
                6) arrowFunction this points to windows obj, but function using function keyword's this point to the
                same Obj.
                7) forEach and Map same function. diff--> map returns a new array, forEach dont return anything.
                8) filter --> the callback function returns a condition. based on the condition it returns a new array
                of elements.
                Note: param for forEach,map,filter is the element of the array.
                9) Chain of filter-map possible. Filter will filter the data based on condition and map can then iterate
                over the filtered list and return a new array.
                10) reduce --> takes 2 params accumulate --> stores the value of the retrun. currentVal --> take the val
                of the ele of the array.
                NOTE: 3rd param is optional it defines the starting value of accumulate.
                11) this behavior depends upon how you declare function.
                NOTE: If function keyword is used then this points to the obj where it's created.
                If arrow function is used this points to the obj which is executing that function.
                12) spread(...) --> lot of uses.
                --use to find min or max in an arr.
                --use to copy or append or merge two objects into a new one i.e fetches all the keys and values from
                others and create a new one.
                --use for destructure of arrays.
                Note: Destructre means createing new variables from the given array OR Object efficently.</p>

            <p>Observations for DOM Events:</p>
            <p>Observations: <br>
                1) using document.querySelector to specifically select any element by id or by tagName or by className.
                2) EventListner can be used efficently than using seperate onclick functions.
                3) if you have looping on eventListner, use this in the callback function to access individual elements.
                4) in frm action attribute if you use # it will stay in the same page. if you use / then it will try to
                redirect.
                5) redirect is a default behaviour that can be prevented using evt.preventDefault() in callback.
                6) change keeps tracks of input change, input keeps track when the input changes
                7) benfit of input --> it ignores arrow and special keys. only tracks when it detects an input change.
                8) Event bubble can sometime helpful but sometime pain in ass :( , use evt.stopPropagation();
                9)basically you can use evt.target.nodeName eg: LI or BUTTON to identify what is clicked inside
                containers like div or ul.
                10) very imp --> ways you can write the callback function
                -- using arrow function. eg: () => {....your code whatever it is....}
                -- calling a specific fucntion without any param. eg: .addEventListner('click', reset);
                -- calling a specific fucntion with param. eg: .addEventListner('click', function() { reset(param1,
                param2); });
            </p>

            <p>Observations for DOM Elements: </p>
            <p>Observations: <br>
                1) diff between .innerText and .textContent --> if something is hidden textContent will show it but
                innerText won't.
                -- Always Good to use textContent instead of innerText.
                2) Note: .getAttribute fetchs from HTML content but .attribute_name fetchs from JS Object.
                3) window.getComputedStyle(document.querySelector('')) --> just to view the current styles implemented
                on a particular element.
                NOTE: document.querySelector('') this is a domObj.
                4) properties to navigate in HTML using DOM
                -- .parentElement --> Goes to the parent element.
                -- .children --> HTML Collections for all the children of that element.
                -- .nextElementSibling/.previousElementSibling --> move around the children.
                -- .createElement('LI') --> create a new Element.
                -- .appendChild(domObj) --> append as a new child at the end.
                -- .append(text)/.preappend(text) --> add some to the existing element.
                -- .insertAdjacentElement(position, element) --> see MDN for what to type in postion eg: afterend i.e
                after the specified element add
                and element is the new element you want to add.
                -- .removeChild(domElement) or .remove().
            </p>

            <p>Observations for DOM Sync Functions and promises: </p>
            <p>Observations: <br>
                1) Js is a single threaded language. At max only one line runs during execution.
                2) delayed execution of callback functions are handled by browser(written in c++). It helps Js to manage
                delayed execution.
                3) Nested deep callbacks called callbackhell.
                4) solution to callbacks hell --> we use promises Obj(return either fullfilled or rejected) based on the
                status of the server call.
                5) using chain of .then()-->if server call successfull and .catch() --> if server call failed make the
                nested call more flat structure.
                6) further optimised implementation is using async func(always returns a promise obj) and await fuc
                call() (wait for the async funct to return a promise obj)
                7) await works only inside a async function. put all the await calls in try block and add a catch block
                at the end. --> Error handling in async function,
                8) previously used AJAX --> Async Js and XML, now we use AJAJ --> Async JS and JSON. The format of
                output now a days mostly is in json.
                9) JSON --> JS Object Notation.
                10) JSON.parse(jsresp) --> string resp from server to JSON Object; JSON.stringfy(JSONObject) -->
                converts JSON Object to String.
                11) For a Web based HTTP API contains --> HTTP verb(GET,POST,UPDATE), HTTP Headers --> info on the resp
                eg: accept --> application/json , HTTP query --> '?' look for a match if the API supports that. eg:
                ?houseNo='45'&streetNo='5'
                12) FOR Making server calls:
                -- XHR --> XMLHttpRequest, no support for promises and callbackshell is a headache. (*Not Recommended
                Atall*)
                -- fetch() --> uses promises. no callbackhell but the resp has to be extracted using resp.json() -->
                returns a promise again. thus bit hassel.
                -- axios --> 3rd party library. have to include script as script. uses promises behind the scenes. resp
                can be extracted easy i.e resp.data (*Recommended*)
                NOTE: you can pass a 2nd optional param to fetch and axios if you need to define specific headers value.
                eg: { headers : {Accept : 'application/json'}}
            </p>

            <hr>
            <hr>

            <p>**Prototypes, classes and OOPS**</p>
            <p>Click here to see the workSpace for prototypes and class: <a href="OOPS/index.html">Click here</a></p>
            <li>objects have access to a Obj templates which are under a special keyword __proto__ or [[prototype]]</li>
            <li>Instead of defining for every obj the same functions, we just define a template obj that the func can
                use whenever needed. eg: Array.prototype, String.prototype</li>
            <li>NOTE: you can add new methods or edit the existing methods for the prototype Obj, [[prototype]] is a
                reference to the actual prototype obj.</li>
            <li>Obj templates are used everywhere in JS. It basically frames the content of any Obj that we declare.
            </li>
            <li>factory function ---> Baiscally the function builds() and returns an object.(not used)</li>
            DrawBack --> Everytime the methods are recreated for every new obj we make.
            ***Constructor function***
            <li>we difine a function starting with Cap Letter, use 'this' keyword inside it.</li>
            <li>then we call this function with 'new' keyword. eg: new fun()</li>
            <li>new --> it will create a new obj for me and the 'this' of the above fun will point to new obj and
                returns it</li>
            <li> --> Also it will add a constructor with the same fun name under [[prototype]].</li>
            <li>New methods can be added under prototype, thus everytime during declaration it is not created again and
                again, which solves the drawback of factory function.</li>
            <li>NOTE: Better to use old school function() keyword for func declaration instead of Arrow function.
                Reason: 'this' keyword behaves differently inside arrow funcitons.</li>
            **Js Classes**
            <li>Makes the above code, clean and pretty syntax.</li>
            <li>class names starts with Caps, add a constructor for that class, this will points to the individual Obj.
            </li>
            <li>best part of using class --> any method you declare inside class will automatically put under prototype
            </li>
            <li>NOTE: Classes basically are the blueprints of anything so the above thing totally make sense.</li>
            <li>NOTE: if two obj share the same prototype class then comparing the fun references i.e obj1.fun ===
                obj2.fun is true. If these are same functions on individual obj then it is false. </li>
            NOTE: Here, let obj2=obj1; thus both are pointing to the same reference.
            <li>Color system --> rgb/rgba, hex, hsl(hue, saturation, lightness) eg: rgba(0-255,0-255,0-255, 0-1),
                #5f6f7f , hsl(0-360, 0-100%, 0-100%)</li>
            <li>Inheritance --> use of extends or super keyword.</li>
            <li>Extends --> child class can extends parent class to use there methods.</li>
            <li>NOTE: same method name in the child and parent will be overwritten with the child's method during
                inhertiance.</li>
            <li>super --> Its forms a refernece to the parent class. eg: child class might wants to add additional
                params, then we can use super</li>
        </ul>
        <br><br>

        <h3>*****Backend World Welcomes you*****</h3>
        <p>We will learn concepts of cmd, nodeJs, using express, mongoDb etc</p>
        <p>Folder to Refer : /d/Desktop Files/Backend Webdev </p>
        NOTEs:
        <ul>
            <li>static webpages --> means its always the same code with the data from the server.</li>
            <li>Dynamic webpage --> On the server side, basically based on the data, the entire webpage is composed.
            </li>

            ***Basic of BASH Commands***
            <li>why we have to use --> it is faster, a lot of access, installed and access to tools(main reason why we
                need terminal).</li>
            <li>Terminal --> A software interface for command line.</li>
            <li>shell --> Programs that run on terminal. eg: CLI(command line interface) in windows.</li>
            <li>Bash --> one of the most popular shell. Running Unix(Linux) shell on Window.</li>
            <li>GIT --> version control software</li>
            <li>NOTE: most web-servers runs on Linux and shell, so we need to have a shell to connect to them.</li>
            <li>NOTE: the windows Terminal, Its MS DOS so its not the correct one. So need GIT BASH.</li>
            <li>GIT BASH --> A package that installs both GIT and Bash at the same time. Provide GIT feature and BASH
                Shell at once.</li>

            ****Commands****
            <li>ls --> shows all the files/folders at the current location.</li>
            <li>pwd --> print working dir. Specify your current location.</li>
            <li>cd ~ --> this takes you to home dir. ~ --> this symbols shows that you are at the home directory.</li>
            <li>cd --> change directory. use to move around the directory. go forward and backward.</li>
            eg: cd /c --> goes to c drive, cd /e --> goes to e-drive
            <li>clear/cntrl + L --> to clear the console.</li>
            NOTE: clear will clear the conosle but cntrl + L is like page up, we move down to a clean space.
            <li>cd .. --> go backward in the fileSystem directory.</li>
            <li>Relative path --> works if the folder is in the same dir eg: cd FolderName</li>
            <li>Absolute path --> works from anywhere, basically you mention the full path. eg: cd
                /user/backendFolder/FolderName</li>
            <li>cd / --> this will go to the root directory.</li>
            <li>NOTE: cd ~ --> is taking to c:/users/sourav i.e home dir. but cd / --> this taking to place where git is installed. i.e root dir</li>
            <li>NOTE: if you have space in file names. follow this, eg: cd /d/Desktop\ Files/Backend\ Webdev </li>
            <li>NOTE: something like this also works --> cd ../../folderName i.e Go back two times and then go inside
                folderName.</li>
            <li>mkdir --> make directory. eg: mkdir newFolder --> creates a new folder at the current dir</li>
            <li>NOTE: mkdir newFold1 newFold2 --> this creates 2 new folders with the given name at once.</li>
            <li>man commandName --> man is for manual, it can be used to know about a particualr command.</li>
            <li>NOTE: Type 'q' go close the page.</li>
            <li>NOTE: we have flags that we can use along with the command. eg: ls -a --> shows all the hidden folders,
                ls -l --> shows the details list of files/folders presents in the dir.</li>
            <li>touch file.txt --> touch command makes new files in the current dir if it doesn't exist else it will
                just update the file creation time.</li>
            <li>NOTE: you can make multiple files in the same dir at once. eg: touch newFile.html app.css app.js -->
                makes all 3 new files at once.</li>
            <li>rm file.txt --> it removes the file from the dir. NOTE: Its just gone. it doesnot go to recycle bin.
            </li>
            <li>rmdir newFolder --> it will removes the folder. NOTE: but works only if the folder is empty.</li>
            <li>rm -rf newFolder --> rf means recurssive forced i.e it will just remove the folder and Everything inside
                it.</li>
            <li>code filename.json --> open the file in the vs code. (****super important, very useful***)</li>
            <li>code . --> open the current dir in a new Vs window.</li>
            <li>cat index.js --> shows the content of the index.js file.</li>
            <li>mv file.js newFile.js --> use to rename/move a file using bash command.</li>
            eg: rename a file: mv test.txt test1.txt --> file name updated.
                move the file: mv test1.txt /d/newFolder/test3.txt --> file is moved and renamed to test3.txt.

            **HOW to Use Linux Vim Editior***
            <li>First you need to go to the location of the target file.</li>
            <li>View content of file: cat myFile.txt </li>
            <li>Open in Vim: vim myFile.txt </li>
            <li>Press i, to go in insert mode. Insert Mode --> here you can add new things/edit existing to the field, use arrow keys to move around the file.</li>
            <li>To save the changes: press Esc(this will save all the actions) then :wq to Exit the VM</li>
            <li>The changes will be reflected on cat myFile.txt </li>

            <p>******NODE JS *************</p>
            <li>Refer: /d/Desktop Files/Backend Webdev/nodeJS_WorkSpace</li>
            <li>NodeJS --> Its a javascript runtime that executes code outside of the browser.</li>
            <li>used for --> making servers(framework --> Express), command Line tool(eg: npm), native App (VS code),
                gaming, </li>
            <li>NOTE: electron --> single platform where with a single code base it can built native app as well as
                support web applications i.e cross platform</li>
            <li>-- Majorly used to build native web application using Js, HTML and CSS for cross-platfrom use.</li>
            <li>-- basically if you have a website, you can make a native application for the same. use electron
                framework.</li>

            **NODE REPL BASIC COMMANDS** Ref: firstNodeScript.js
            <li>REPL --> Read Evaluate Print Loop. It will continue to listen and evaluate when we write any command and
                print the result.(Type node in bash and it will open REPL)</li>
            <li>Browser JS vs native Js(node) --> browser JS supports document(supports DOM) and windows(global obj in
                browser). node dont have.</li>
            <li>Node --> It comes with built-in module like access to OS and File system. Browser dont have. </li>
            <li>NOTE: The global obj in node JS is called "global"</li>
            <li>To run the js code in node --> node fileName.js (make sure you are in the correct dir.)</li>
            <li>process --> this is availble in the global scope. It contains all the information on the current node.js
                file i.e its version,release, its dir, memory etc</li>
            NOTE:
            process.argv in the node repel --> it just returns the node root path.
            process.argv inside a Js folder --> returns the path of node with the path of the file that is currently getting executed.
            <li>use of process.argv --> it returns a list.
                -- first_index--> node path or execution path,
                -- second_index-->js file path,
                -- after that it will return all the argv passed in the command line.
                eg: node filename.js arg1 arg2 </li>  
            NOTE: here process.argv is inside filename script, and this will return a list, node root, script path and argv1 and argv2.

            **File System using node REPL** Ref: createWebFolder.js
            <li>Two ways of file methods --> sync(it will stop the execution untill the work by the method is done) and
                async</li>
            <li>const fs = require('fs') --> this will include the file system in the process.</li>
            <li>fs.mkdirSync('folderName') --> creates a new folder in the current dir</li>
            <li>fs.writeFileSync('fileName.html', '') --> creats an empty file at the current location.</li>
            <li>NOTE: always use try and catch for sync methods as they dont have any callbacks.</li>

            **require and module.exports*** AppRef: require_and_exports
            <li>module.exports --> used to define what are the things from current file can be accessable to other files when you require it.</li>
            <li>NOTE: require a file in the same dir, syntax --> require(./filename)</li>
            <li>-- exports also can be used. NOTE: make sure we dont assign 'exports' keyword as a variable, then it wont refer to module.exports anymore.</li>
            <li>-- by deafult module.exports is a empty object i.e {}</li>
            NOTE: eg: module.exports.keyObj = Obj i.e module.exports is an object containing a key called keyObj which has value Obj.
            <li>For require a directory --> it will look for the 'index.js' file in the dir. It will exports whatever this index.js has added to module.exports</li>
            eg: const req = require('./cars'); here cars is a folder, inside that we have index.js
            
            **NPM command Line tool**
            <li>NPM --> node package Manager. For Refernece: <a href="https://www.npmjs.com/">npm_guide</a></li>
            <li>Storehouse of tones of library that we can use. and also managing the packages.</li>
            <li>NOTE: package for react, package for express etc.</li>
            <li>npm i packageName or npm install packageName --> to install a new package.</li>
            <li>Once install, see the documentation, require it and use the available exports methods.</li>
            <li>Global package -->  when you install a package add '-g'. that makes the package availble globally. eg: npm i -g cowsay</li>
            <li>NOTE: 
                -- Global packages added can be used just like normal command. eg: cowsay hellooo</li>
                --  To link a global package to a folder, use npm link packageName. eg: npm link cowsay.</li>
                -- This will ensure require('cowsay') works in the destination folder.
                -- Mostly used for packages that give new commands. else mostly packages are isntall specific to one dir.</li>
            <li>package.json --> contains meta-data of the given package.</li>
            <li>index.js --> main or starting file for any npm package or node project folder.</li>
            <li>Notes: 
                -- npm init --> this command will ask few questions and create a properties.json file.
                -- previously if this file is missing from the package install location it used to throw error. but now it will automatically create when we install a package.
                -- All the packages that you install for that project dir will be automatically added to project.json file.
            </li>

            ***working with Project that has dependencies*** AppRef: jokeMaker, figlet_Demo, language_guesser(Package is ESM only)
            <li>-- node_module folder wont be shared. so visit the project.json file, check the dependencies and isntall them manually one by one.</li>
            <li>-- npm install or npm i --> this command will look for the project.json file and download all the dependencies automatically.</li>
            <li>Importance: package.json file in the project workspace keeps track and manages the required packages for the project. *Always maintain this one file*</li>
            <li>Note: for uninstalling a pcakge: npm uninstall packageName</li>
            <li>Note: eg: npm uninstall pack1 pack2; npm i pack1 pack2 --> pack1 and pack2 are being uninstalled and installed again fresh with latest version.</li>
            <li>some npm package are purely ESM(ECMAScript Module) --> we have to use import instead of require(). also some changes to project.json file.</li>
            <li>-- eg: import {franc} from 'franc';
                -- NOTE: require only exists in cjs file(common js) not in ESM module. In ESM we use import
                -- add in project.json --> "type": module, this will enable ES import/Export.
            Note: to use require in ESM add the following *IMP* 
                import { createRequire } from "module";
                const require = createRequire(import.meta.url);
            </li>

            **Express Package** AppRef: expressfirstApp
            <li>It is a framework used to create servers for web development using node.</li>
            <li>Reference to documentation: <a href="https://expressjs.com/">Click here to see Node documentation</a></li>
            <li>uses: to build web applications i.e web servers and APIs. and Every processing involved in the processing the client data.(same as middleware layer)</li>
            <li>Library vs framework:
                -- both are codes that open source avaiable.
                -- eg of library: bootstrap, axios(a http library) etc.
                -- with library, you decide when to use it. it provides methods for a very particualr purpose.
                -- with framework, framework is in control and you just need to follow it. It basically used to built big applications like web apps, games etc. eg: express
            </li>
            <li>Note: your app name should be all lowercase.</li>
            <li>express keywords:
                -- const express = require('express'); cosnt app = express(); --> this returns an express obj that we can use and it also starts the express server.
                -- .listen(port, ()=>{...})  --> it listens if anything happening in that port.
                -- .use(()=> {...})  --> it responds anytime we have an incomming request. basicallly any incoming request will trigger this.
                -- cntrl + c --> this will down the server.
            </li>
            <li>NOTE: from here onwards in the below notes 'app' refers to const app = express();</li>
            <li>httpRequest is a text information. 
                -- express takes this data and pass it as req --> incomming req object and res --> outgoing obj</li>
            <li>.use((req, res)=>{...}) --> this is how to use req and res.</li>
            <li>res.send() --> this will send the response back to the client in form of html text, normal text or json Object.</li>
            <li>Note: you cannot receive multiple response from a single request.
                -- app.use responds to all incoming requests.
                -- So for routing we will use a different method from express. </li>
            <li>Any call from browser url is a get call to the server.</li>    
            <li>Routing in servers:
                -- it refers to taking incoming req the new path that is requested and matching that to some code in that path.
                -- bsically you are at localhost:8080/home and wants to go to localhost:8080/dogs, routing needed in the server side code.
            </li>
            <li>app.get('/cats', (req, res)=> {...}) --> this will run whenever the request url matches this syntax.</li>
            <li>Note: '/' --> refers to the home page. eg: app.get('/', (req,res)=>{...})</li>
            <li>Note: app.get('*', (req,res)=>{...}) --> **this has to be added at the end**. It will match all path for the get call.</li>
            <li>Note: 
                -- app.get() just respond to any get calls
                -- post calls can be handled by app.post eg: app.post('/cats', (req, res)=> {...})
            </li>
            <li>Note: route are match in order they are define. eg: All get calls route will be matched in order they are defined.</li>
            <li>Express path parameter
                -- ':' is used to define a path paramter in the requested path by the client.
                -- eg: app.get('/r/:search', (req,res)=>{...}) --> here search is the param name and the value is taken whatever you pass.
                -- req.params return an object for all the params in the request.eg: {search : "aboutpage"} if the call is for /r/aboutpage
            </li>
            <li>Express query Strings
                -- '?' --> after this whatever is there in the url is a query string.
                -- req.query --> this will return an object that contains info on the query 
            </li>
            <li>Note: multiple queries can be passed in the url. eg: /search?q=location&tag=dog.
                -- req.query returns {q : "location", tag : "dog"}
            </li>
            **Automatically restart the server**
            <li>Generally if we change out code base, server needs to be restarted for it to reflect.</li>
            <li>we can use nodemon package.</li>
            <li>install nodemon --> npm i -g nodemon  (install nodemon globally)</li>
            <li>then run nodemon index.js --> this will watch for any change in code base in any of the js file and automatically restart the server.</li>
            
            **Templating***
            <li>Instead of writing static html code, we can emmbed logic of a page as a template that can be reuse anytime we want </li>
            <li>Templating engine used for it : EJS (embedded JavaScript), other examples: handlebars, jade, pugjs, Nunjucks all are have different syntax but used for making templates.</li>
            
            **EJS**
            <li>Reference to this ejs : <a href="https://ejs.co/">Click here</a></li>
            <li>app.set(name, value) --> we can specify a particular property and its value that will effect the configuration of the server </li>
            <li>NOte: no need to require ejs in the script. app.set('view engine', 'ejs') will tell the express to use ejs behind the scenes.</li>
            <li>-- By Deafult, Express assume our templates are in a folder called views. (*Important*).[its the deafault dir but you can change it using app.set()]</li>
            <li>-- the views contains file with the format of .ejs</li>
            <li>-- res.render() --> it will render the view(it will process the ejs file that has html and js) and send the formatted html file back to the client.</li>
            **EJS views Folder:***
            <li>
                -- holds all the .ejs template files for the project. 
                -- If you are running the server from current dir where views is present it will work.
                -- If you are running the server from outside it will not work ! :(
                -- solution: We use const path = require('path') and use a method called app.set('views', path.join('__dirname', '\views');
                -- by default express takes current_dir/views. The above method change it to the project_dir/views.
            </li>
            
            **EJS Syntax** AppRef: firstAppEJS
            <li><%= ... %>  --> between this you can write any Javascipt code. '=' here means it will take that js value and render it in the html.</li>
            <li>template should only handle display of the dynamic data. The logic can be written in the js file and passed to the template.</li>
            <li>Note: pass the data from the js to ejs template file as key-value pair in form of json Object. In ejs file, access the value with the key.</li>
            <li>eg: { num } is same as {num : num}</li>
            <li><% ... %> --> this means it wont be rendered to the html but it will run as normal js code.</li>
            <li>NOTE: for loop / If condition we write between this.</li>
            <li>.json files usually contains the data to be displayed in the page. We need to require it in order to access it. eg: const data = require{./data.json}</li>
            <li>Note: {...obj} --> this will spread the object. hence you can access each data just by there key.</li>
            <li>NOTE: Remeber if you want to show some data value dont forget to use <%= ... %> and if you want to run some Js code in html then use <% ... %></li>
            
            **Include static files like cssFile, images, fonts etc***
            <li>we put all the static files in a dir. eg: public and serve it in our project using express.static('dirName')</li>
            <li>Static is a express built-in middleware function to serve static file in the your project.</li>
            <li>NOTE: include the absolute path of the public dir so that it can accessable from any place.</li>
            <li>Once you server the contents of the public dir. they are literally avaiable for you to use in your template and also this works --> localhost:8080/app.css</li>
            NOTE: Never try to include the public folder name in the template link path. What the folder contains is served not the folder.
            
            **Partials in EJS** AppRef: EJSwithBootstrap
            <li>It's a way of including templates in other templates.</li>
            <li><%- include('templateName') %> -- this way you can include other templates in each other. </li>
            
            **GET and POST handling from FORM Data** AppRef: handlingFrmData
            <li>GET --> Anything you request from the server.Refelects in the url as query String or param.</li>
            <li>POST --> you send the content to the server in the body. The payload is a part of the body</li>
            <li>Express has .get and .post to handle them seperate.</li>
            <li>req.body --> This will have the body content that is sent via POST request. By default it is undefined(for Form payload) and {}(for json body payload)</li>
            <li>NOTE: We need to explicitly make express to parse the body in a particular format.</li>
            **use this middleware to handle the req.body data: const bodyParser = require('body-parser'); 
            <li>app.use(bodyParser.json()) --> parse the data passed as json format.</li>
            <li>app.use(bodyParser.urlencoded({ extended: true })) --> parsing frm encoded data.</li>
            NOTE: we can use like: app.use(express.urlencoded({extended:true}));  //this also works
            
            **REST** AppRef: restFul_comment_API
            <li>REST --> representational State Transfer. System which follows REST guidlines are called RESTful.</li>
            <li>To Crate a CRUD layer for APIs we generally follow the REST protocols.</li>
            <li>Redirect of webpage</li>
            <li>-- when you use res.redirect('url'), the default code that is sent is 302.</li>
            <li>-- it follows up and makes a second call to the redirect url.</li>
            <li>-- the redirect path is stored as location that is included in the response header </li>
            **UUID npm package**
            <li>-- Gives unique ids that we can use as unique elements while searching.</li>
            <li>-- just require it and use it.</li>
            
            <li>PUT/PATCH --> Put updates everything in the payload for a particular id, Patch only partially update for a particular id.</li>
            <li>NOTE: HTML FORMs can just send get or post method. For update we need to fake it.</li>
            <li>**method-override**</li>
            <li>-- this allows us to use http methods are Put and delete where they are not allowed. eg: in a HTML form</li>
            <li>-- install it and then require it.</li>
            <li>-- app.use(method-override(_method)) and in the from we use: form method ="post" action = "/comments/?_method=PATCH"</li>
            <li>-- this tells express to look for a method that is being assigned in the _method.</li>
            <li>-- Remember here the action url should be proper with the query and method should be post.</li>
            
            **Database**
            <li>Why ?
                -- data persistence --> stores the data even if the serves restarts.
                -- should able to handle large volume of data, also makes handling of data easy.
                -- provides lots of tools for insert, delete or query something.
                -- offers Data security
            </li>
            <li>SQL vs No-SQL Database
                -- SQL eg: oracle,mysql,mssql,postgresSql
                -- No-SQL eg: mongoDB, cassandra, couch DB 
            </li>
            <li>SQL-> Data stored in form of tables. All the tables are related to each other. plan ahead before you have procced with the database.</li>
            <li>No-sql --> deverse data it can store. no tables. more flexibility.</li>
            
            **Mongo**
            <li>why ?
                -- most commonly used with node or express
                -- strong community and easy to start with.
            </li>
            <li>Installation is a headache really man !!!</li>
            <li>Install the mongo server and shell. and then set it as the path parmater in the windows environment</li>
            <li>Vs code connected to mongo using an extension and mongosh Repel we can run inside Vs code</li>
            **Mongo Basic Commands**
            <li>mongosh --> this starts the mongo Repel.</li>
            <li>cls or cntrl+L -> clear the screen</li>
            <li>NOTE: the syntax is similar to JS. also the reason why it is popular.</li>
            <li>show dbs --> this command will show all the running dbs.</li>
            <li>use dbName --> It will make a db for me if not present OR Switch to a particular db</li>
            <li>NOte: if the db is empty, it will not show in the dbs list.</li>
            <li>Mongo Expect a data format called BSON.</li>
            <li>Why not use JSON ?
                -- it's a text based format and text parsing is slow.
                -- not space efficient.
                -- supports a limited number of dataTypes.
                -- eg: JSON can only store object,number,string,boolean, Array.
                -- mongo can store all including different types of numbers(float, long etc), date (Mostly used), Raw Binary.
            </li>
            <li>BSON:
                -- similar to JSON but not JSON.
                -- BSON --> Binary JSON.
                -- we can write normal JSON, Mongo converts it and store in Binary JSON Format.
            </li>
            <li>Insert in mongo
                -- we insert into a collection. if collections not there db.collectionName will create a new collection.
                -- db.collectionName.insertOne({}) -- one element inserted at a time, 
                -- db.collectionName.insertMany([{},{},{}]) -- multiple elements added to the collections at a time.
            </li>
            <li>show collections -- will show the collections.</li>
            <li>db.collectionName.find() --> It will list down all the collection Elements you inserted.</li>
            <li>_id: primary key, unique for every entry in the collection.</li>
            **MongoDB query**
            <li>db.collectionName.find({key: "value"}) --> returns the data based on the match else retrun empty.</li>
            <li>find() --> returns a cursor(kind of pointer) a refernece to the find Result from the collection.</li>
            <li>find({qty:{ $lt: 30 }}) --> same as qty < 30.</li>
            <li>find({$or:[{A},{B}]}) --> same as A or B {</li>
            <li>find({A, B}) --> same as A and B</li>
            **Mongo Update**
            <li>db.collectionName.updateOne({}, {}) or use updateMany({},{})</li>
            <li>Special Operator:
                -- {$set: {A:"", B:""}} --> update A and B
                -- $currentDate: {lastmodified: true} -- this will update the last modified Data with the current Date.
            </li>
            <li>NOTE: if the field is not there that you are updating and set will add a new field</li>
            <li>db.collectionName.replaceOne({}, {}) --> replace the entire conent of the matched.</li>
            **Mongo Delete**
            <li>db.collectionName.deleteOne({}) or db.collectionName.deleteMany({})</li>
            <li>-- based on the condition it will delete.</li>
            <li>NOTE: db.collectionName.deleteMany({}) -- delete everything in the DB.</li>
            <li>db.collectionName.drop()--> This will drop the collection entirely.</li>
            <li>db.dropDatabase() --> this will drop the entire the db.</li>
            **Additonal Commands in mongo Shell**
            <li>If the key is nested and you want to search it. use: .find({parentkeyName.childKeyName : value})</li>
            <li>Other Operators:</li>
            <li>-- Refer here to see different kind of mongo operators: <a href="https://www.mongodb.com/docs/v6.0/reference/operator/query/">Click here</a></li>
            <li>-- $gte,lte,gt,le --> >=,<=,>,<               </li>
            <li>-- $in --> checkes for multiple values. eg: find({breed : {$in : ['Mutt', 'Corgi']}})</li>
            
            **Mongoose**Reference: mongooseBasic/index.js
            <li>Reference Link: <a href="https://mongoosejs.com/">Click here</a></li>
            <li>-- It's basically makes the process of connecting to mongoDB easy and simple.</li>
            <li>Mongoose is known as ODM -> Object Data Mapper/Object Document Mapper</li>
            <li>Note:
                -- It basically connects the nodeJs to Mongo.
                -- It maps the data that comes back from Mongo to useable JS Object.
                -- It also Provides ways for model out app data and define schema. also includes validation of Data.
            </li>
            <li>NOTE: ORM -> Object Relational Mapper.
                -- This tool helps If we use a Relational Database like MySql or PostgresSql or Oracale, It will map that relational data to usable JS Object.
            </li>
            <li>package needed is: mongoose. require the same in the index.js</li>
            <li>NOTE: mongoose connection returns a promise so we can validate the connection.</li>
            <li>Models: models are Js classes that we make with the instance of mongoose that represent info in the mongo db.</li>
            <li>Steps in mongoose:
                -- Acheive a successfull Connection to the mongo DB.
                -- we need to define a scheme that maps the DataType from the DB.
                -- after this we have to create a new Model Class from this schema.
                -- now you can create objects for this class and then use save() to add the changes to the class to the db.
                -- OR You can use the class itself to perform various Mongo DB operations basically CRUD Operations.
            </li>
            <li>NOTE: For Model Creation the name of the model Should me First Letter caps eg:Item which interally mongoose makes a collection like eg: items </li>
            **Very important Notes For Mongoose CRUD Operations**
            <li>Most of the Model and mongoose methods returns a thenable Promise like Object. As Db operations takes time.
                -- models and mongoose methods returns a thenable promise like object. that works good with .then() and .catch() chains.
                -- If you want to use await then we need to add .exec() at the end of the Model methods thats returns a proper promise Obj.
            </li>
            <li>Normal updateMany and updateOne methods will also work but it will just return the number of records updated. So we use the below method.</li>
            <li>Moongose FindOneAndUpdate method
                -- This will by default return the old record as new keyword is defaulted to false.
                -- To fetch the latest updated record we need to add {new: true}
            </li>
            <li>Mongoose Delete
                -- DeleteOne and DeleteMany can be used but it wont return the data that is deleted.
                -- instead use findOneAndDelete, it will return the data that is deleted.
            </li>
            <li>NOTE: (**Good Feature of Mongoose**)
                -- Mongoose uses something called Operation Buffering, that allows to use our model immediatly without waiting for the mongoose connection to Establish.
            </li>
            <li>**mongoose Schema Validation**</li>
            NOTE: *See the Documentation for mongoose under schema Types*
            <li>-- The way we structure the Model Schema we can do more things.</li>
            <li>-- we can add validation like required: true/false</li>
            <li>-- type checks if the passes argument can be converted to the one that is spefied in the schema.</li>
            <li>-- Any additonal params that you pass other then defined in the schema will be simply ignored.</li>
            <li>-- Default - It is used to set a defualt to an entity. </li>
            <li>-- We have constraints for a particular dataType also. 
                eg: For String --> lowercase, uppercase, trim, match etc
                    For number --> min, max etc.
                    ... and so on for other DataTypes.(Refer the Mongoose Documentation for it)
            </li>
            <li>***NOTE***</li>
            <li>-- Mongoose Schema Validation only works when you insert a new Data in the DB.</li>
            <li>-- If you Try to Update an Existing Data it will not work.</li>
            <li>Solution:
                -- Need to exculsively Tell mongoose to run the Validation while updating the Data.
                -- add runValidators to the Option -> {new: true, runValidators: true}
                -- new: true --> returns the updated entry as resp and runValidators:true --> implements the schema validations while updating.
            </li>
            <li>**Custom Validation Error Messages**</li>
            <li>example:  min: [8, 'This is too small'] 
                -- here 8 is the min value allowed
                -- and then the text is the error msg if the validation is not meet. 
            </li>
            <li>Note:
                -- enum validator: Defines an Array of options for the above item to take.
                -- eg: size: {type: String, enum: ['S', 'M']} --> means size can be only 'S' or 'M'
                -- Any other input for Size will be invalid.
            </li>
            NOTE: we can add our own custom methods to Model class.
            ***************************************************************************************************************
            NOTE: 
            -- Most of the time, .load filename in the Node REPEL, will load the file, and we can use it to check the code.
            ****************************************************************************************************************
            **Model Instance Methods** Reference: mongooseBasic/Product.js
            <li>Instance method --> methods which are present in every instance of the Object. eg: const prod = new Product(), here prod is the instance of the class Product.</li>
            <li>Class/static methods --> methods which are present on the class Object. eg: Product.someMethod(), here Product is the class.</li>
            1) We will see how to define custom methods on the instance of a class / Instance Methods ***
            <li>NOTE: use the syntax: schemaName.methods.myFunction = function() {...} </li>
            <li>CAution: Dont use arrow functions, Always use the normal function declaration using the function keyword.</li>
            <li>Use this whenever we have to handle something related to manipulation of the data or update.</li>
            2) Model Static Methods**
            <li>This methods are on the Model directly(on Product Class) rather than on their instances(on prod instances)</li>
            <li>-- 'this' keyword for static methods refers to the Model itself</li>
            <li>-- eg: productSchema.static.myFunc = function() {...}</li>
            NOTE:
            <li>**Difference between instance method and static method**
                -- Instance method are very specific on one Instance of the model Class.
                -- Every Instance of that model class has access to the isntance method.
                -- Static methods are on the Model Itself. It effects are reflected on all the items rather than specific.
                -- They are just a facny way of implementaing Existing Model method for CRUD Operations.
            </li>
            ***Mongoose Virtuals*** Reference: mongooseBasic/Person.js
            <li>-- it allows us to add property(virtual property) to the schema that dont actually exist in the db itself.
                -- basically, If you want a field that has the value of two fields from the actual db. but you dont store this new field in the db. 
                -- We use Virtual. </li>
            <li>syntax: dbSchema.virtual('fieldName'), then set a getter and setter for this. i.e .get() and .set()</li>
            <li>Virtual Property -> This property doesn't really exist in the schema but uses existing schema to maintain a virtual property in the code.</li>
            <li>Needs to define getter and setter for a Virtual Property.</li>
            
            **Mongoose middleware** 
            <li>-- It provides a way to run code before or after any operation we do like update or delete or saved.</li>
            <li>It inlcudes per and post hooks.</li>
            <li>-- .pre() --> runs before the specified operation is executed.
                -- .post() --> runs after the specified operation is executed.
            </li>
            <li>NOTE: this middleware pre and post hooks is very important and powerful concept in the mongoose.</li>
            <li>NOTE: Custom instance method, static method, virtual Property, mongoose middleware all this are on the schema and should be define before the Model creation.</li>
            
            **EXpress+Mongoose** Reference: express_mongose/index.js
            <li>Full Crud Operations with Express and mongoose and mongoDB.</li>
            <li>-- Models generally are put under a  different model files because in real Life project we have many models.</li>
            <li>-- seed.js --> This file is run seperate from the main index file, Basically used for development purposes, just to put some data in the mongo database.</li>
            <li>NOTEs: 
                -- Product.InsertMany([{},{}...]) checks for validation of all the payload before inserting it in the db. If anyone fails no data will be inserted.
                -- The calls inside the routes, includes mongoose operations are often handled using await. Since they are db operations and returns a thenable promise like result.
                -- declare the callbacks async so that you can await the response of the mongoose calls.
                -- Normally we dont use name for searching anything, we rather use ID.
                -- If we want to use names, we need to convert that to web slug, basically make it url safe. eg: my_name_is (no blank spaces).
                -- findById(idfromDB) --> used to get the matching record for that Id.(use this for Normal search)
                -- findOne({key: value}) --> return the first matched record for the value of the specified key.(use this if you want to search by name or any other key).
                -- Never Forget, In EXpress Route, the order of the function invokes from top to bottom.
                -- Role of a seed Folder, It is used mostly for testing the code by inserting some data in the DB.
                **Important --> Seed files are run once and seperately then the main project index file.
            </li>
            
            **Concept of middleware** (Very important concept)
            *middleware*
            <li>-- functions have access to req, res obj and other middleware functions and that run during res/req life cycle. 
                -- eg: we have parse the req.body form data using the middleware. OR we use middleware method to serve static files in express.
                -- middleware can end http req by sending res.send(), also can be chained together by using next().
            </li>
            <li>Note:
                -- app.use() -> will run on every single call. It tells the express what to execute when it listens anything.
            </li>
            <li>Morgan Middleware</li>
            <li> -- example of an external middleware tool, mostly used for logging.
                 -- eg: morgan('tiny') --> logs what the server is listening to...
            </li>
            <li>Defining Middleware --> we need to add next as param and also need to add next() in the body.</li>
            <li>How to call the next middleware method ?</li>
            <li> -- we pass a parameter called next and add next() in the fucntion body.
                 -- If you dont put next(), it just stops there and wont move ahead ahead.
                 -- eg: it runs the middleware function use() and then next() will find the next function in the file to execute.
                 -- if you put res.send() then it stops everything.
            </li>
            <li>Note: Anything after next() will still run but it will run at the end.
                -- usually we always return next(); to avoid executing anything after next()
            </li>
            <li>Note: **very important**
                -- with the middleware calls and the route call in the same express app.js
                -- the order in which we write the calls matter in express.
                -- Express will start matching the income request from the top till bottom. First match will be first to execute.
            </li>
            <li>app.use('/testUse', (req,res, next)=>{...}) ==> this will run only where it will match the incoming route having a path: /testUse
                -- It will run for all the verbs be it get,post,patch,put or delete for the req with url: /testUse
            </li>
            <li>app.use() also used to define a 404 not found route handle.
                -- It is always written at the end of the index.js file.
                -- it will run if none of the routes matches.
            </li>
            **Very important**
            <li>route handlers like app.get() can have muliple callbacks. eg: app.get('/show', callback1, callback2)
                -- callback1 need to have next(); then once it completed it will move to callback2 and so on.
                -- if callback1 fails and it hits res.send() in callback1 function then all other subsiquent callbacks will never execute.
            </li>

            **Express-Error handling**
            <li>-- use of next param in callback and next(); is very crucial to understand for Express-middleware working.
                -- if you use next(), then the route will run and then it will move below to check the other routes as well.
                -- only if you use res.send(), it will cancel the execution of middleware one after another.
            </li>
            <li>Errors that are generally encountered are like, moongose validation, causing syntax error inside the route callbacks, submitting incomplete forms etc.</li>
            <li>**Default built-in express-handling**
                -- if express encounters any error, it can handle it using the default express error handler.
                -- it returns a 500 internal server error httpstatuscode with an html response of the stack trace of the error encountered.
                -- Note: we can also throw error object with the error message. eg: throw new Error('..msg..');
            </li>
            <li>**Custom Error-handling middleware fucntion**
                -- for error handling midddleware function, pass 4 params in the callback: err, req, res and next.
                -- also put it always at the last after all the app.use() and routes calls.
                -- this custom error handler will run whenever express gets any kind of error.
                -- **very-imp** if you call next(), the server will search for non-error handling middleware, but next(err) --> it will search for the next error handling middleware.
                -- next(err) in custom error handling function will call the default express-error handling middleware.
                -- One major advantance, By handling the errors, it will not crash the server, instead it will show a proper error message.
            </li>
            <li>**Custom Error class**
                -- Errors are of many types like 401 or 400 or 500 etc. So classifying them is necessary.
                -- we can define one class extending the default error class that takes the custom statusCode and message, the errorHandler Middleware will use this to show to httpStatusCode and Error message.
                -- Basically instead of using the error Object directly we will create our own class AppError to handle the statusCode and exception message.
                -- Note: whenever we throw a new Error('..msg..'), it will have the error msg and the stack trace, It doesnot have the status code by default.
                -- But, Internally Express default error handlers will look for the status or the status code to handle the error, so specifying the status of the request is important.
            </li>
            <li>**handling Async Errors**
                -- mostly whenever we are interacting with db calls, we are using async functions. handling errors in these cases is important.
                -- important: we must pass the error returns by async middleware and route calls to the next(), so that the default middleware can act on it.
                -- always write: return next(new AppError('msg', 500)), this will stop the execution there only and wont trigger any other line after it, else it will try to render the page with undefined data.
                -- we can handle the error in one more way, use the try..catch block, In catch, catch the err and call next(err), this will trigger the error handler middleware.
                -- note: using catch, it will catch any error from mongoose and also any error that we are throwing inside the try block.
                
                **Very Important***
                Instead of using try..catch block at every route and so many times, we can deine a wrapAsync function to take care of catching the error
                -- Basically the entire async call (from thSe route call) is passed as param to this wrapAsync func which returns a functions, that executes the passed function from the later and have a chained catch to catch any errors.
            </li>
            <li>**Mongoose Error handling**
                -- Mongoose throws different types of errors and also have an error name. eg: validation error, cast error if the search id is invalid, it cannot convert it into the object_id
                -- Use the custom Error handler class to manually throw the error and the async Utility function will catch this error and throw it to the custom error handling middleware to handle it.
            </li>
            <li>NOTE: *summary of Error handling in express* 
                -- If any error occured anywhere in the code, the custom error-handler middleware at the end of the code will catch it and process it with the default value of status and message.
                -- All the async routes callbacks, errors are handle by a asyncErrorhandler function thats has a chained catch to catch any error and pass it to next(err) that triggers the custom error-handling middleware at the end.
                -- We can also handle mongoose and other req data invalid error by throwing custom Error message by passing the suitable message and status code, that will be catch by either of the above 2 handlers and processed.
            </li>
            <li>**JOI Schema validation and Middleware***
                -- It is a new npm package, js validator tool that does the schema level validation and throw approriate errors.
                -- joi provides an Joi object which validates the income data against the schema you have defined in the Joi object.
                -- it scalable and also it sits on top of client side validation, Thus it catches the error if you do it from postman too.
                -- Baiscally, add the schema validation in form of a joi object and then valiate it. If any error, destructure the err object and throw the custom Error Handler msg out.
            </li>
            
            *Mongo Data Relationship* (How to store Related Data in mongo) 
            <li>-- structuring the database with multiple entites having some relationship between them in a noSQL database.
                -- there are different kind of relationship possible among the tables: eg: one to many, many to many.
                **One to Many Relationship in Mongo**
                -- example: mostly if user-data is involved, then its one to many. Because, One user can make only one type change in any other database entity.
                -- it includes:
                **one to Few** (mapped if the size of data is small)
                -- example relationship between user and their address, in this kind of cases we store the address directly inside the parent table.
                -- inside, addresses will be list with its own unique id, you can turn it off by adding this in the schema for address: _id: {id: false}
                -- It is used only when you have the the embedded data very less. Like a user has most likely to have less addresses.
                
                **One to Many** (mapped if the size of data is medium)
                -- store the mapped data in a different schema, but then the parent should contain the a reference i.e objectId of the mapped data.
                -- here, in the Parent Schema, you need to particular mention the type as mongoose.Schema.Types.ObjectId. Note: Its not the native JS Object, it comes from mongoose.
                -- alse we need to add: ref: 'mapped Model name', it tells mongoose where to pick the data from during populate.
                -- In this, The data stored in the parent will be just ids of the mapped Model, We can use populate to extract the data from these.
                -- .populate('fieldName') --> it will take the ids and populate that with the corresponding data for that particular field.
                NOTE: without populate you will get just linked Ids for mapped schmeas, with populate you will get their respective data too. Both ways are very useful.

                **One to bajillion** (mapped if the size of data is huge)
                -- eg: all tweets belonging to a single users, so a user will have thousands of tweets.
                -- Solution: parent id is stored in the child schema.
                NOTE: populate('fieldName', optional) --> this optional can be any particular field from the child schema, which will be populated just alon if we add that field name as the second paramter to populate.
            </li>
            **Important**** --Rules for one to Many Realtionships and how to handle them.
            <li>***Mongo Schema Design***
                **6 Rules of Thumb for mongo Design:
                1) denormalization: Its okay to sometime duplicate the same field-data in different schema.
                -- instead of putting a relationship, between 2 schemas, we can simply add the data as a field. Thus, saved from using populate and all that.
                2) understand how the data is related to each other, and then decide which relationship is better or if at all its needed in the first place.
                3) If the linked data is more than 100 --> better to use one to many concept(store the child id in parent). If the data is more than 1000 --< better to use one to bajillion concept(store the parent id in child).
                -- basically, you should not design the schema like the array is growing without any stop point, If true then store the parent id in child else store the child id in parent.
                4) application-level joins --> along with storing the id, you also put field that you will use frequently to reduce the use of populate.
                5) always denormalize a field that is just read most of the time and less update.
                6) model of the data is totally depends upon the application mainly on how you query the data and updates it.**most important Rule**
            </li>
            <li>NOTE:
                **Two Way Referencing concept***
                -- Basically we can combine the one to many and one to bajiliion concept into one concept.
                -- MEans, parent id is stored in every child, and child id is stored in the parent.
                -- this ensures 2-way communication between the schema.
            </li>
            
            **Express + Mongo Relations***(APP: ExpresAndMongooseRelationship)
            <li>Note: Alwasys understand the usecase of the collections we need in the project and decide what relation we want.</li>
            <li>-- Made an entire Farm-product functionality with 2 related schema having bi-directional relationship.</li>
            <li>NOte: **Verry Important** 
                --> Mongoose middleware is very very different from Express middleware. Both look similar but not at all same.
            </li>
            <li>Handling deletion of related schema using  mongoose middleware:(Take help from the mongoose middleware documentation)
                -- mongoose has 4 types of middleware -> document middleware, aggregate middleware, model middleware, query middleware.
                -- here see the documentation of the query and see which middleware its triggereing.
                -- we will use query middleware, because it will be triggered by any mongoose query we make from the express index file like findById or FindByIdAndDelete etc.
                -- we will write the middleware as pre and post hooks in the schema file, with the middleware function name(check from the documentation the middleware function name that query triggers) that the particular query will trigger.
                -- NOTE: In pre middleare we will not have access to the data, but in the post middleware we will have access to the mongoose query data.
                -- NOTE: to delete all data from a list of ids use like this: deleteMany({_id: {$in: {arrayName}}}).
            </li>
            
            ***Express Router***   Refernce: ExpressRouters
            <li>Breaking Down the Router page like app.js or index.js that contains all the route handlers into small chunks. Basically used in large projects.</li>
            <li>use express.Router
                -- we can group different routers together.
                -- create a new folder routes and put all the Group routers in it.
                -- export the same and then use app.use('/test', testRoute);
                -- this will bring all the Routes we have defined from testRoute js file and prefix the route with /test 
            </li>
            <li>Basically this lets you decide and group Routes together and make it more convinent to handle routes having similar names agian and agin.</li>
            <li>Aslo we can define one middleware for a particular group of routes if we want so.</li>
            ****Very important***
            <li>NOTE:
                -- when you define Router, it likes to keep the param coming from the app.js seperate.
                -- solution: we need to pass one property, const router = express.Router({mergeParmas: true});
                -- thus any Params coming as a part of fixed router prefix will be treated as a param. else it wont treat it as a param.
            </li>
            
            ****Cookies****
            <li>what ? 
                -- Little bit of the information that we can store in the user's browser. Mostly a name-value pair.
                -- Everytime a user comes to a page. we sent a cookie with a unique identifier to this user. Next time when he comes back we send the cookie along with the request. Helps us to understand about the user's track on that page.
            </li>
            <li>Why ?
                -- we can use cookies to remember little info on the user and store it in the user's browser itself.
                -- Cookies allow use to make HTTP stateful. HTTP is stateless by default. 
                -- Means Http doesnot remember any past things or events. Cookies stores info that helps to store few but crucial info thus stateful.
            </li>
            <li>use ? 
                -- session management
                -- personalization, we can use cookies some info about user's preferences.
                -- tracking. (Major use of cookies), It stores what the users have done on that page.
                NOTE: We dont use cookie's to store user information. we just store small, basic info.
            </li>
            <li>Sending a Cookie
                -- we use res.cookie(name, value), to store any cookie in the browser. Once saved the browser will hold on to it.
                -- It has many properties other than just name and value like path, size, HttpOnly, Secure etc.
                Note: Even if you close the tab and open it again, cookies will be stored in the browser.
            </li>
            <li>Retrive a cookie:
                -- we use a npm package to parse the cookie: cookie-parser 
                -- trigger the middleware, app.use(cookieParser()), the req.cookies will return all the stored cookies in the browser.
            </li>
            <li>Signing Cookies
                -- its kind of a seal the cookie with a secret code. It makes sure none tampers with the cookie that is stored in the browser.
                -- need to pass a secret key in the cookie-parser middleware which it will use to seal the info off.
                NOTE: It is not about hidding or encrept the data. it's just there to ensure the validaity or intigrity or tamparing of the stored data in the cookies.
                -- If it was tampered then that cookie cannot be retrived or it will just return false.
                NOTE: The secretkey is onetime, Once set it cannot be chnaged. If done then all signed Cookies cannot be checked for tampering.
            </li>
            <li>Working of cookie-parser
                -- it uses something called HMAC: Hash-based message auth code. 
                -- It basically sign the value with a secret using SHA256 (Hashing algo). This returns a signature code.
                -- For verification, It takes the value and do the hashing again and then it generates the signature again and compare it with the existing sign.
                -- if it matched, its fine, if not then the cookie is tampered.
            </li>
            
            Why Session ? Why Not cookies ? 
            <li> -- There is a limit on the number and size of cookies that are allowed per browser.
                 -- cookies stores data in the client-side in the user's browser but session stores data in server-side. 
                 -- cookies are not practical or secure to store lot of data client-side. that's why we used sessions.

            </li>
            ***Session in Webpages****
            <li>Sessions are server-side data store that makes HTTP stateful.</li>
            <li>
                -- sessions are not to be confused with data source or data storage. 
                -- session can run without databases, they have session data stores in the server side that can persist the data.
                -- example of redis, it a database that is used for short term storage, ideal for session data source
            </li>
            <li>HOw it works ? 
                -- Data is stored in the session data storage and a cookie with the id is stored in the browser.
                -- to unlock the session this cookie will give you the id, which the server will contact data store and fetch the respective details for that id. 
            </li>
            <li>Express-session 
                -- npm Package available for handling session.
                -- define the middleware, app.use(session({...})); inside session you can pass many options for security and production env.
                -- We will pass, secret: 'someSecretKey' -- the session will sign the cookies with this secret key.
                -- Now everytime a req hits the server, we will find a session cookiee related to this express-session, (connect.sid)
                -- All the cookies will be store here under req.session.cookieName
            </li>
            <li>NOTE:
                -- The default server side storage for express-session is memoryStore(Local memory, it is persistence as long as the session lasts)
                -- This is not designed for production env, it will cause memory Leak and doesnot scale past single process.
                -- It is build only for debugging and developing.
                -- For Production env, we can define any one of the open source compatible session-store available. eg: connect-redis or mongo store etc(refer documentations for express-session)
            </li>
            <li>Main Conclusion:
                -- Cookies are very important for sessions, They store the session Id in the user's browser that contains all the session Info for that User.
                -- If Cookies are deleted then all the stored session Info also Gone :( ;
            </li>
            
            ***Flash***
            <li>
                -- npm package: connect-flash 
                -- Main Purpose: In the session, It can falsh message to the user eg: success or failure message.
                -- It just comes and go, happens after successful submission, or redirect or some kind of action.
            </li>
            <li>use ? 
                -- flash messages are stored in session, so session middleware should be there.
                -- After including it and putting the middleware, app.use(flash()).
                -- req.flash('info', 'flash message'); -- first param will have something like key eg:info or danger or success or error, followed by the flash message.
                -- now the above one will store it in session.
                -- to retrive from the session, res.render('pageName', {message: req.flash(flashKey)});, use the message in the rendered page.
            </li>
            <li>Problem: 
                -- We need to write it at many places for every Routes we define.
                solution:
                -- Define a middleware and use res.locals
                -- res.locals contains variables that are availble only to the views rendered during the req/res cycle.
            </li>

            ***Authentication and Authorization*** (Very very Important)
            <li> Authentication ? 
                -- It verifies who is the person is ? eg: username/password or faceId or security questions.
            </li>
            <li>Authorization ? 
                -- It strictly happens after Authentication.
                -- It checks what access that person who logged in has ? eg: Is he an Admin, maintaince guy or a customer.
            </li>
            *** How password is stored ?***
            <li>
                -- pass are never stored in text. (**Never ever do that**)
                -- we hash the password i.e We run the password through an hashing algorithm and then store it in database.
                -- hashing function:
                   Generalized function, which takes a arbitary sized input and spits out a completely deifferent fixed sized response.
            </li>
            **Cryptographic Hashing Functions**
            <li>
                features of Cryptographic password hash functions: 
                  -- Its not invertable. Only one way function. eg of one way funtion, Math.abs(x), output is always post. but input we dont know if it was post or negative.
                  -- small change in input, output will change drastically.
                  -- same input is always has the same ouput. i.e should be a Deterministic Algo.
                  -- Output of 2 input should never be same and clash each other.
                  -- slow processing. so negate the change the brute force to crack the function.
            </li>
            NOTE: Cookies are signed using a fast Cryptographic hash function, SHA-256, Since its fast, not suitable for password hashing.
            <li>**Password salting**
                -- something extra we do apart from hashing that makes the hashed password more secure.
            </li>
            <li>** Why Salting needed ? 
                -- if we have access to the hashed password, and we know the password hashing algorithm.
                -- we can basically brute force and create a reverse hash lookup table(Pre-computed based on the hashing algo) for the password and try frequently used passowrd untill it is cracked.
                -- one more problem is people use the same password sometime, so salt make sure their's hashed output are different from each other.
            </li>
            <li>** How to salt the password ? 
                -- WE just add a random value before hashing the function.
                -- This ensures we get a very unique and this also remove any chance of reverse hashTable thing since we are using a random value in our password.
            </li>
            NOTE:
            -- Salts are not secret keys, they just add more randomness to the hashing function, provide unique hashed and secure result.

            **Bcrypt (Our password hashing Function)**
            <li> npm packages:
                bcrypt -> It is purely for server side. It will run in node JS. and it is faster. written in c++.
                bcrpt.js -> It is built for client side as well as server-side i.e can work in browser as well as in node. written entirely in JS.
            </li>
            *** WE will be using bcrypt *** (we will run ours in server-side alone)
            ***Setting up Bcrypt Password Hashing package 
            <li>
            -- We will be using Bcrypt as our Password hashing function.   
            -- npm packaging: Bcrypt
            -- we need to provide saltRounds, It kind of means the difficulty level of hashing you want aka the amount of time to hash. ideally it should be 12.
            -- lower the number of saltRound faster the algo will run, more is the time, slow it will run, robust the hashed password will be.
            -- Bcrypt uses 2 function, one to generate a salt and the hash takes pwd and salt and generates a hashed password.
            NOTE: 
            -- No need to store salt while using bcrypt, bcrypt inbuilt has compare function which can recognise the salt from a hashed function.
            -- more saltRound, more time it takes in hashing, ideal set it to 12.
            -- Also, each time you run, salt value will change that puts randomness in the hashed pass generated.
            </li>
            <li> How do the compare my password ?
                -- bcrypt has compare function that takes hashed and plain text and see if it matches or not.
            </li>
            NOTE: 2 functions we need for hashing password using bcrypt:
            -- hash --> this generates the hashed function, params: passText and saltRound.
            -- compare --> this comapre passtext and hashedpass to see if they mathes. params: passText and hashedPass(generally stored in DB).

            **Authentication From Scratch using express-session and bcrypt***
            <li>NOTE:
                -- While implementing login post request, dont use get, else the pass and username will be visible in the url. (NOT Recommended)
                -- Always use POST route to take the login frm submit redirect.
                -- Generally in auth, UserName should be unique so that we can search using that.
                -- Any problem either with the username or password, we show a genralised error saying, Invalid username or password (**Very Important**)
                -- WE will be using session to know if a person is loggedin or not and if he can access the routes. Thats the proof that a user is logged in or not.
                -- Generally we stores the userId of the logged in User in the session, Its easy to fetch user details whereever needed.
                -- Logout, Its all about removing the session stored user details.
                -- Furthere we can define Schema.statics methods in our Model to Check and Validate Users. It reduces the code in the main app.js file.
                -- Also the Hashing of the function can be handeled by model itself. We can run a mongoose middleware before save action i.e a pre hook.
                **Very IMportant**
                -- In the model, we have access to one method called isModified(fieldName), It checkes if the fieldName is modified or not.
            </li>
            <li></li>
            <li></li>
            <li></li>
            <li></li>
            <li></li>
            <li></li>
            <li></li>
            <li></li>
            <li></li>
            <li></li>
            <li></li>
            <li></li>
            <li></li>
            <li></li>
            <li></li>
            <li></li>
            <li></li>
            <li></li>
            <li></li>
            <li></li>
            <li></li>
            <li></li>
            <li></li>
            <li></li>
            <li></li>
            <li></li>
            <li></li>
            <li></li>
            <li></li>
            <li></li>
            <li></li>
            <li></li>
            <li></li>
            <li></li>
            <li></li>
            <li></li>
            <li></li>
            <li></li>
            <li></li>
            <li></li>
            <li></li>

            <p>***Building a fully functional Website including Servers and interactive UI using all important concepts of WEB-DEV-Fundamentals***</p>
            <li>Important NOteS:
            **Setting up the basic Routes and Templates for the project**
                -- Make the project modular, Try with basic route and keep the model and seed files seperate.
                -- To include partials in your dynamic HTML template, we can use a package called ejs-mate.
                **ejs-mate**
                -- ejs-mate is better and efficent than using partials for templating duplicate things in project.
                -- add the npm package, add the app.engine for ejs to ejs-mate. define boilerplate.ejs with the dynamic body tag.
                -- we define a boilerplate template and then whenever you call layout('boilerPlate location') in one form, it is passed to the <%- body %> area of the boiler plate template.
                -- textArea --> Dont have a value attribute.
                -- in bootstrap, class="col-md-4 offset-4 mb-5", means you will occupy 4 md columns out of 12 and adding offset will start it after the starting 4 columns.
                -- in form, class= "d-inline", will push the form to get inline with the rest of the content.
            *******************************************************************************************************************************************************************************************************    
            NOTE(Just something that needed to be very clear):
                -- JS by nature runs sync, means runs the code line by line, top to bottom.
                -- if a function is async it means, anything after that function will run immediately.
                -- async funs always return a promise object, which is either resolved or failure based on the nature of the response.
                -- inside the async fun, if we have multiple calls to db, or file or api, we can use await function, it will await for the response to come and then move to the next server call.
                -- That is why we use await only inside async funcs, to wait for the response of the server call.
                -- eg: setTimeout is a built-in async call, it runs the callback back function after the specified time, but won't block other function written after it. those will run anyway.
                    After the specified time, automatically, the response will be printed out. Thus Async Functions are powerful Functions :> RESPECT THEM !
            *******************************************************************************************************************************************************************************************************    
            
            **Including Server-side and client Side validations**
                -- Client-side validation options available, we can use the html 5 inline 'required' keyword to do the validations (handled by the browser) or can use the bootstarp validation class (makes more sense and looks nice too).
                -- use the bootstrap validations to do the client side validations.
                -- Note: using novalidate in form as attribute will ignore any required added for any input.
                
                -- Server-side validation, we need to handle mongoose error and middleware errors.
                -- add the custom error-handler class, add a util folder, with custom ExpressError fun and the wraperAsync catch function(this will catch error inside async functions).
            Note: if you use app.all('*', (req,res,next)=>{...}) --> this will trigger if none of the top route matched. (It has to be at the end, because route order is important).
                -- declare custom error handler and throw error whereever required to handler possible mongoose error or req body or param error etc.
                
                -- For schema validation, we will use Joi schema valiation, put it as a middleware function and call it before the route callbacks of post and edit.
                -- if this middleware throws an error, the default custom middleware at the end will catch it and process it.

            **Adding Review Model for Our Yelp-camp**
                -- New Review Schema is add. 
                -- Review and Campground schema will have one to many Relationship. single campground can have mulitple reviews.
                -- make sure before writing the route call, What will be the best url for that route. eg: Since i need to store camp details also while svaing a review, Route should have the campground id.
                -- client side validation is needed, using botstrap validation method and form level validations.
                -- server side, add a Joi Schema validation and async middleware to catch any error in the from schema or during any mongoose operations.
                ****VEry Important, Very useful****
                -- For Deleting Review functionality, we are going to use a Mongoose operator $Pull, it can remove any matching value from an array that satisfys the conditions, Syntax: { $pull: { <field1>: <value|condition>, <field2>: <value|condition>, ... } }
                ***********************************
                -- Another Situation: If a campground is deleted, then whole List of comments associated with it also needs to delete.
                -- campground delete middleware,
                
                ***Restructuring the Campgroud index.js and Adding cookies and Sessions***
                -- we Have shited all the Campgrounds related routes to one seperate folder with all the required dependencies.
                -- we Have shited all the Review related routes to one seperate folder with all the required dependencies.
                    NOTE: **Very Important**
                    -- In review related routes, as prefix we will be sending campID as path param 
                    -- For Express Router to treat it as path param, we must pass one param while defining Router.
                    -- eg: const Router = express.Router({mergeParmas: true});                
                
                    -- Next we have to manage our static elements including breaking down the boiler scripts and put a public folder and serve it using express.Static().
                -- NOTE: If you are serving a folder using express.static like views and public, the entire content of the folder is served and you can directly used without mentioning the dir path.

                -- Configuring session and Flash
                    -- For now we will be using the local memory session store. Later we will move it to mongo.
                    -- we will send some cookie paramter also like expire, maxAge(in millisecond) and httpOnly (Extra security that saves from accidental reveal of cookies to 3rd party) --> refer the express Documentation.
                    -- setup connect-flash and flash middleware to make use of flash messages on actions.
                    -- flash partials for success and error alerts Done.
                

            </li>
        </ul>
    </main>
    <hr>
    <footer>
        <p>This is my HTML WorkBook </p>
        <p>Thank You &excl; </p>
        <a href="nextPage.html">Go to Next Page </a> -->
    </footer>
</body>

</html>